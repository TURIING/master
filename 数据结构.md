### 第2章 线性表

`定义`  具有==相同数据类型（每个数据元素所占空间一样大）==的n个数据元素的==有限序列==  

`性质`  

* 除第一个元素外，每个元素有且仅有一个直接前驱；

    除最后一个元素外，每个元素有且仅有一个直接后继

`其他`  

* 线性表中元素的**位序是从1开始的**，而数组中元素的下标是从0开始的

* **链式存储结构比顺序结构更能方便地表示各种逻辑结构**

* **设有尾指针的单链表执行删除最后一个元素的操作与链表长度有关**

* |         顺序存储         |     链式存储     |
    | :----------------------: | :--------------: |
    | ==可随机存取、顺序存取== | ==只能顺序存取== |

#### 顺序表示

又称__顺序表__

`特点`  ==随机访问==[^1]、==存储密度高==[^2]、==拓展容量不方便==、==插入、删除操作不方便，需要移动大量元素==

`性质`

* 在第$i（1\leq i \leq n）$个结点后插入一个结点，==需要后移$n-i$ 个结点==，时间复杂度为O(n)

##### 代码实现

`静态分配`

```c
#define MaxSize 10

typedef struct {
	int data[MaxSize];
    int length;
}SqList;

void InitList(SqList &L) {
    for(int i=0; i<MaxSize; i++) {
        L.data[i] = 0;
    }
    L.length = 0;
}
/*
 *	i: 插入的位序（需区别于数组的下标）
 *	e: 插入的元素
 */
bool ListInsert(SqList &L, int i, int e) {
    //判断索引是否合法
	if (i<1 || i>L.length+1)
        return false;
    //判断表满
    if (L.length >= MaxSize)
        return false;
    //后面的元素后移
    for (int j=L.length; j>=i; j--) {
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = e;
    L.length++;
    return true;
}
/*
 *	i: 删除的位序
 *	e: 删除的元素
 */
bool ListDelete(SqList &L, int i, int &e) {
    if (i<0 || i>L.length)
        return false;
    //取出被删除的元素
    e = L.data[i-1];
    for (int j=i; j<=L.length; j++) {
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}
/*
 * i: 位序
 */
int GetElem(SqList L, int i) {
    //判断是否越界
    if (i<0 || i>L.length)
        return -1;
    return L.data[i-1];
}
int LocateElem(SqList L, int e) {
    //循环查找
    for (int i=0; i<L.length; i++) {
        if (L.data[i] == e)
            return i+1; 									//返回位序
    }
    return -1;
}
```

`动态分配`

```c
//默认的最大长度
#define InitSize 10

typedef struct {
    int *data;
    //顺序表的最大容量
    int MaxSize;
    //顺序表当前的长度
    int length;
}SeqList;

bool InitList(SeqList &L) {
    L.data = =(int *)malloc(InitSize * sizeof(int));
    if (L.data == NULL)
        return false;
    L.length = 0;
    L.MaxSize = InitSize;
    return true;
}
void IncreaseSize(SeqList &L, int len) {
    int *p = L.data;
    L.data = (int *)malloc(InitSize + len) * sizeof(int));
    //转移旧数据
    for (int i=0; i<L.length; i++) {
        L.data[i] = p[i];
    }
    L.MaxSize = L.MaxSize + len;
    free(p);
}
bool Empty(SeqList L) {
    return (L.length == 0);
}
bool Full(SeqList L) {
    return (L.length >= L.MaxSize);
}
/*
 *	i: 插入的位序（需区别于数组的下标）
 *	e: 插入的元素
 */
bool ListInsert(SeqList &L, int i, int e) {
    //判断插入的位置是否合法
    if (i<1 || i>L.length+1)
        return false;
    //判断表满
    if (Full(L))
        return false;
    //后面的元素后移
    for (int j=L.length; j>=i; j--) {
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = e;
    L.length++;
    return true;
}
/*
 *	i: 删除的位序
 *	e: 删除的元素
 */
bool ListDelete(SeqList &L, int i, int &e) {
    //判断i的位置是否合法
    if (i < 0 || i > L.length)
        return false;
    //取出将要被删除的数
    e = L.data[i-1];
    for (int j=i; j<=L.length; j++) {
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}
int GetElem(SeqList L, int i) {
    //判断是否越界
    if (i<0 || i>L.length)
        return -1;
    return L.data[i-1];
}
int LocateElem(SeqList L, int e) {
    //循环查找
    for (int i=0; i<L.length; i++) {
        if (L.data[i] == e)
            //返回位序
            return i+1; 
    }
    return -1;
}
```

#### 链式表示

`其他`

* **头结点与头指针的区分**：

    ①不管带不带头结点，头指针始终指向链表的第一个结点[^3]

    ②头结点是带头结点的链表中第一个结点，结点内通常不存储信息

* **引入头结点的优点**：

    ①由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的

    ​	 操作和在表的其他位置上的操作一样，无须进行特殊处理

    ②无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空），

    ​	 因此空表和非空表的处理也就得到了统一

##### 单链表

`不带头结点`

```c
typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

bool InitList(LinkList &L) {
    L = NULL;										//空表暂时没有任何数据
    return true;
}
bool Empty(LinkList L) {
    return (L == NULL);
}
bool ListInsert(LinkList &L, int i, int e) {
    if (i < 1)										//判断位序i是否合法
        return false;
    //不带头节点时，插入位置正好为表头时，得单独处理
    if (i = 1) {
        LNode *s = (LNode *) malloc(sizeof(LNode));
        s->data = e;
        s->next = L;			//L是指向第一个结点的指针，故此处将s指向原本的第一个结点
        L = s;										//将s作为第一个结点
        return true;
    }
    LNode *p;
    int j = 0;										//记录p指向的节点的位序
    p = L;											//L指向头节点，从头开始
    while (p != NULL && j < i - 1) {
        //循环扫描
        p = p->next;
        j++;
    }
    if (p == NULL) 									//i值超过表长，不合法
        return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    //下面的顺序不可交换
    s->next = p->next;
    p->next = s;
    return true;
}
```

`带头结点`

```c
typedef struct LNode {
    int data;
    LNode *next;
} LNode, *LinkList;

bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
}
bool Empty(LinkList L) {
    return (L->next == NULL);
}
//按位插入
/*
 * i: 位序
 */
bool ListInsert(LinkList &L, int i, int e) {
    if (i < 1)
        return false;
    LNode *p;
    int j = 0;												//记录p指向的节点的位序
    p = L;													//P指向头节点，从头开始
    while (p != NULL && j < i - 1) {//由于带头，故位序即位置；此处找到i的前一个结点而已
        p = p->next;
        j++;
    }
    if (p == NULL) 					//i的前一个都找不到了，i结点自然不存在，即i值不合法
        return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    //下面的顺序不可交换
    s->next = p->next;
    p->next = s;
    return true;
}
//指定节点的后插操作
bool InsertNextNode(LNode *p, int e) {
    if (p == NULL)
        return false;										//判断指定节点是否存在
    LNode *s = (LNode *) malloc(sizeof(LNode));
    if (s == NULL)
        return false;										//分配内存失败
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//指定节点的前插操作
//先完成后插，再交换数据以实现前插
bool InsertPriorNode(LNode *p, int e) {
    if (p == NULL)
        return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    if (s == NULL)
        return false;
    s->next = p->next;
    p->next = s;
    s->data = p->data;
    p->data = e;
    return true;
}
//按指定位序删除节点并返回其值
bool ListDelete(LinkList &L, int i, int &e) {
    if (i < 1)
        return false;
    LNode *p;
    int j = 0;
    p = L;
    while (p != NULL && j < i - 1) {					//找到指定结点的前一个结点
        p = p->next;
        j++;
    }
    LNode *q = p->next;
    e = q->data;
    p->next = q->next;
    free(q);
    return true;
}
//删除指定节点
bool DeleteNode(LNode *p) {
	if(p==NULL)
        return false;
    LNode *q = p->next;
    p->data = q->data;									// 交换数据
    p->next=q->next;
    free(q);
    return true;
}
//按位查找，返回第i个元素
LNode *GetElem(LinkList L, int i) {
    if (i<0)
        return NULL;
    LNode *p;
    int j = 0;											//记录p指向的是第几个结点
    p = L;
    while(p!=NULL && j<i) {								//找到第i个结点
        p = p->next;
        j++;        		
    }
    return p;
}
//按值查找
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while(p != NULL && p->data != e)
        p = p->next;
    return p;
}
//返回表长度
int Length(LinkList L) {
    int len = 0;
    LNode *p = L;
    while(p->next != NULL) {
        p = p->next;
        len++;
    }
    return len;
}
//尾插法建立单链表
LinkList List_TailInsert(LinkList &L) {
    int x;
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    LNode *s,*r = L;
    scanf("%d", &x);
    while(x!=9999) {
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL;											//置空
    return L;
}
//头插法建立单链表
LinkList List_HeadInsert(LinkList &L) {
    int x;
    L = (LinkList)malloc(sizeof(LNode));
    LNode *s;
    L->next = NULL;
    scanf("%d", &x);
    while(x!=9999) {
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;
        L->next = s;
        scanf("%d", &x);
    }
    return L;
}
```

##### 双链表

```c
//带头节点
typedef struct DNode {
    int data;
    struct DNode *prior, *next;									//前指针和后指针
} DNode, *DLinkList;

//初始化
bool InitDLinkList(DLinkList &L) {
    L = (DNode *) malloc(sizeof(DNode));
    if (L == NULL)
        return false;
    L->prior == NULL;
    L->next == NULL;
    return true;
}
//判空
bool Empty(DLinkList L) {
    return (L->next == NULL);
}
//指定节点的后插操作
bool InsertNextDNode(DNode *p, DNode *s) {
    //注意顺序不可交换
    s->next = p->next;
    if(p->next != NULL)										//判断是否有后继结点
    	p->next->prior = s;
    s->prior = p;
    p->next = s;
    return true;
}
//删除P节点的后继节点
bool DeleteNextNode(DNode *p) {
    if (p == NULL)
        return false;
    DNode *q = p->next;
    if (q == NULL)											//P节点没有后继
        return false;
    p->next = q->next;
    if (q->next != NULL)									//q不是最后一个节点
        q->next->prior = p;
    free(q);
    return true;
}
//销毁整个表
bool DestroyList(DLinkList &L) {    
    while (L->next != NULL)									//循环删除并释放每个节点
        DeleteNextNode(L);
    free(L);
    L = NULL;

}
//从P点向后遍历
bool PrintNextDNode(DNode *p) {
    if (p == NULL)
        return false;
    while (p != NULL) {
        printf("当前节点的值是:%d", p->data);
        p = p->next;
    }
    return true;
}
//从P点向前遍历
bool PrintPriorDNode(DNode *p) {
    if (p == NULL)
        return false;
    while (p != NULL) {
        printf("当前节点的值是:%d", p->data);
        p = p->prior;
    }
    return true;
}
//从P点向前遍历（跳过头节点）
bool PrintPriorDNodeOverHead(DNode *p) {
    if (p == NULL)
        return false;
    while (p->prior != NULL) {
        printf("当前节点的值是:%d", p->data);
        p = p->prior;
    }
    return true;
}
```

##### 循环单链表

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

//初始化一个循环单链表
bool InitRLinkList(LinkList &L){
    L=(LNode *)malloc(sizeof(LNode));
    if (L=NULL)
        return false;
    L->next=L;								//头节点nex指向头节点，以此形成循环链表
    return true;
}
//判断P是不是表尾指针
bool IsTail(LinkList L,LNode *p){
    return (p->next == L);
}
```

##### 循环双链表

```c
typedef struct DNode{
    int data;
    struct DNode *prior,*next;
}DNode,*DLinkList;

//初始化
bool InitRDLinkList(DLinkList &L){
    L=(DNode *)malloc(sizeof(DNode));
    if (L==NULL)
        return false;
    L->prior=L;
    L->next=L;
    return true;
}
//判断节点p是不是循环双链表的表尾节点
bool iTail(DLinkList L,DNode *p){
    return (p->next == L);
}
//在p节点之后插入s节点
bool InsertNextDNode(DNode *p,DNode *s){
    s->next=p->next;
    p->next->prior=s;
    s->prior=p;
    p->next=s;
    return true;
}
//删除操作
bool DeleteNextDNode(DLinkList &L,DNode *p){
    DNode *q = p->next;
    p->next=q->next;
    q->next->prior=p;
    free(q);
    return true;
}
```

##### 静态链表

`指针`  指结点的相对地址（==数组下标==），又称游标

`注意`

* 静态链表也需要==预先分配一块连续的内存空间==

**优点**：==增删改查不需要移动大量元素==

**缺点**：==不能随机存取==、==容量固定不变==

```c
#define MaxSize 10
//第一种定义方法
struct Node0{
    ElemType data;
    int next;											//下一个元素的数组下标
};
//第二种定义方法
typedef struct Node{
    ElemType data;
    int next;
}SLinkList[MaxSize];
```

### 第3章 栈和队列

#### 栈

只允许==在一端==进行插入或删除操作的==线性表==

`概念`

__栈顶__: <u>进行插入删除的那一端</u>

__栈底__: 不允许插入和删除的另一端

__特性__: ==后进先出==

`性质`

* ==n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C_{2n}^n$==

##### 顺序表示

```c
#define MaxSize 10
typedef struct {
    ElemType data[MaxSize];
    int top;													//栈顶指针
} SqStack;

//初始化
void InitStack(SqStack &S) {
    S.top = -1;											//栈顶指针始终指向栈顶元素
}
//入栈
bool Push(SqStack &S, int t) {
    if (S.top == MaxSize - 1)
        return false;											//栈满
    S.top += 1;
    S.data[S.top] = t;
    return true;
}
//出栈,并打印出栈顶元素
bool Pop(SqStack &S, int &x) {
    if (S.top == -1)
        return false;											//栈空
    x = S.data[S.top];
    S.top -= 1;
    return true;
}
//读取栈顶元素
bool GetTop(SqStack S, int &x) {
    if (S.top == -1)
        return false;
    x = S.data[S.top];
    return true;
}
```

```c
#define MaxSize 10
typedef struct {
    ElemType data[MaxSize];
    int top;													//栈顶指针
} SqStack;

//初始化1
void InitStack(SqStack &S) {
    S.top = 0;								//栈顶指针始终会指向栈顶元素的下一空元素
}
//入栈
bool Push(SqStack &S, int t) {
    if (S.top == MaxSize)
        return false;
    S.data[S.top++] = t;
    return true;
}
//出栈
bool Pop(SqStack &S, int &x) {
    if (S.top == 0)
        return false;										//栈空报错，注意判空条件
    x = S.data[--S.top];
    return true;
}
//读取栈顶元素
bool GetTop(SqStack S, int &x) {
    if (S.top == 0)return false;
    x = S.data[S.top - 1];
    return true;
}
```

##### 共享栈

* ==top0 = -1时，0号栈为空；top1 = MaxSize时，1号栈为空；==

* ==top0 + 1 = top1时，栈满==
* ==共享栈是为了更有效的利用存储空间==

```c
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int top0;												//0号栈顶指针
    int top1;												//1号栈顶指针
} ShStack;

//初始化
void InitStack(ShStack &S) {
    S.top0 = -1;
    S.top1 = MaxSize;									//MaxSize就是第二个栈的栈底
}
//入栈
bool Push(ShStack &S, int t) {
    if (S.top0 + 1 == S.top1)
        return false;										//栈满
    S.data[++S.top0] = t;
    return true;
}
//出栈
bool Pop(ShStack &S, int &x) {
    if (S.top0 == -1)
        return false;										//栈空
    x = S.data[S.top0--];
    return true;
}
//读取栈顶元素，栈0
bool GetTop0(ShStack S, int &x) {
    if (S.top0 == -1)
        return false;
    x = S.data[S.top0];
    return true;
}
//读取栈顶元素，栈1
bool GetTop1(ShStack S, int &x) {
    if (S.top1 == MaxSize)
        return false;
    x = S.data[S.top1];
    return true;
}
```

`栈的链式存储结构`

通常采用单链表实现，所有操作都是在单链表的==表头==进行的

__优点__: ==便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况==

```c
#define MaxSize 10
typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} *LinkStack;

bool InitStack(LinkStack &LS) {
    LS = (LinkNode *) malloc(sizeof(LinkNode));
    if (LS == NULL)
        return false;
    LS->next = NULL;
    return true;
}
bool Push(LinkStack &LS, int t) {
    //入站不需要检查栈满
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    if (s == NULL)
        return false;
    s->data = t;
    s->next = LS->next;
    LS->next = s;
    return true;
}
bool Pop(LinkStack &LS, int &x) {
    if (LS->next == NULL)
        return false;													//栈空
    LinkNode *q;
    q = LS->next;
    LS->next = q->next;
    x = q->data;
    free(q);
    return true;
}
bool GetTop(LinkStack LS, int &x) {
    if (LS == NULL)
        return false;
    x = LS->next->data;
    return true;
}
```

#### 队列

**只允许在一端进行插入，在另一端删除的<u>线性表</u>**

`概念`

__队头__: <u>允许删除的一端</u>

__队尾__: <u>允许插入的一端</u>

`特性`

==先进先出==

##### 顺序存储

队头指针front指向队头元素；队尾指针指向队尾元素的下一个位置

__队空条件__: Q.front == Q.rear == 0

```c
//第一种实现
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int front, rear;
} SqQueue;

void InitQueue(SqQueue &Q) {
    Q.rear = Q.front = 0;
}
bool QueueEmpty(SqQueue Q) {
    return Q.front == Q.rear;
}
bool EnQueue(SqQueue &Q, int t) {
    //因为判空条件为rear、front指向同一位置，故判满只能牺牲一个空间，所以rear+1
    if ((Q.rear + 1) % MaxSize == Q.front)
        return false;												//队满
    Q.data[Q.rear] = t;
    Q.rear = (Q.rear + 1) % MaxSize;				//通过取余操作让整个队列循环起来
    return true;
}
bool DeQueue(SqQueue &Q, int &x) {
    if (Q.rear == Q.front)
        return false;												//队空
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize;
    return true;
}
bool GetHead(SqQueue Q, int &x) {
    if (Q.front == Q.rear)
        return false;
    x = Q.data[Q.front];
    return true;
}
```

```c
//第二种实现
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int front, rear;
    int size;							//利用size变量记录队列长度，并用作判满的条件
} SqQueue;

void InitQueue(SqQueue &Q) {
    Q.rear = Q.front = 0;
    Q.size = 0;										//初始长度
}
bool QueueEmpty(SqQueue Q) {
    return Q.size == 0;
}
bool EnQueue(SqQueue &Q, int t) {
    if (Q.size == MaxSize)
        return false;								//队满
    Q.data[Q.rear] = t;
    Q.rear = (Q.rear + 1) % MaxSize;				//通过取余操作让整个队列循环起来
    Q.size++;
    return true;
}
bool DeQueue(SqQueue &Q, int &x) {
    if (Q.size == 0)
        return false;								//队空
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize;
    Q.size--;
    return true;
}
bool GetHead(SqQueue Q, int &x) {
    if (Q.size == 0)return false;
    x = Q.data[Q.front];
    return true;
}
```

```c
//第三种实现
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int front,rear;
    int tag;		//利用tag变量记录最后一次操作是什么，0为删除，1为插入,并用作判满的条件
}SqQueue;

void InitQueue(SqQueue &Q) {
    Q.rear=Q.front=0;
    Q.tag=0;										//初始化最后一次的操作状态
}
bool QueueEmpty(SqQueue Q) {
    return Q.front==Q.rear && Q.tag==0;				//只有删除操作，才可能导致队空
}
bool EnQueue(SqQueue &Q, int t) {
    if(Q.front==Q.rear&&Q.tag==1)
        return false;								//只有插入操作，才可能导致队满
    Q.data[Q.rear]=t;
    Q.rear=(Q.rear+1)%MaxSize;
    Q.tag=1;
    return true;
}
bool DeQueue(SqQueue &Q, int &x) {
    if(Q.rear==Q.front&&Q.tag==0)
        return false;								//队空
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MaxSize;
    Q.tag==0;
    return true;
}
bool GetHead(SqQueue Q, int &x) {
    if (Q.rear==Q.front&&Q.tag==0)
        return false;
    x=Q.data[Q.front];
    return true;
}
```

##### 链式存储

```c
//链式队列（带头节点）
typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} LinkNode;
typedef struct {
    LinkNode *front, *rear;
} LinkQueue;

void InitQueue(LinkQueue &Q) {
    //初始化时，front 、rear 都指向头节点
    Q.front = Q.rear = (LinkNode *) malloc(sizeof(LinkNode));
    Q.front->next = NULL;
}
bool EnQueue(LinkQueue &Q, int x) {
    //不需要判满
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    if (s == NULL)
        return false;
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;									//新节点插入到rear之后
    Q.rear = s;											//修改表尾指针
    return true;
}
bool DeQueue(LinkQueue &Q, int &x) {
    if (Q.front == Q.rear)
        return false;									//队空
    LinkNode *p = Q.front->next;						//用指针p记录队头元素
    x = p->data;										//用x变量返回队头元素
    Q.front->next = p->next;							//修改头节点的next指针
    if (Q.rear == p)									//此次是最后一个节点出队
        Q.rear = Q.front;								//修改rear指针
    free(p);
    return true;
}
bool GetHead(LinkQueue Q, int &x) {
    if (Q.front == Q.rear)
        return false;									//队空
    x = Q.front->next->data;							//用x变量返回队头元素
    return true;
}
bool QueueEmpty(LinkQueue Q) {
    return Q.front == Q.rear;
}
```

```c
//链式队列（不带头节点）
typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} LinkNode;
typedef struct {
    LinkNode *front, *rear;
} LinkQueue;

void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = NULL;
}
bool EnQueue(LinkQueue &Q, int x) {
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    if (s == NULL)
        return false;
    s->data = x;
    s->next = NULL;
    if (Q.front == NULL) {
        Q.rear = Q.front = s;						//插入第一个元素时，需要做特殊处理
    } else {
        Q.rear->next = s;									//新节点插入到rear之后
        Q.rear = s;											//修改表尾指针
    }
    return true;
}
bool DeQueue(LinkQueue &Q, int &x) {
    if (Q.front == NULL)
        return false;										//队空
    LinkNode *p = Q.front;									//用指针p记录队头元素
    x = p->data;											//用x变量返回队头元素
    Q.front = p->next;										//修改头节点的next指针
    if (Q.rear == p)										//此次是最后一个节点出队
        Q.rear = Q.front = NULL;
    free(p);
    return true;
}
bool GetHead(LinkQueue Q, int &x) {
    if (Q.front == NULL)
        return false;										//队空
    x = Q.front->data;										//用x变量返回队头元素
    return true;
}
bool QueueEmpty(LinkQueue Q) {
    return Q.front == NULL;
}
```

##### 双端队列

**双端队列**：只允许从==两端插入、两端删除==的线性表

**输入受限的双端队列**：只允许从==一端插入、两端删除==的线性表

**输出受限的双端队列**：只允许从==两端插入、一端删除==的线性表

#### 栈和队列的应用

##### 括号匹配问题

**思路**：<u>依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配</u>

```c
# define  MaxSize 10
typedef struct {
    char data[MaxSize];
    int top;
} SqStack;

void InitStack(SqStack &S) {
    S.top = -1;											//栈顶指针始终指向栈顶元素
}
bool Push(SqStack &S, char t) {
    if (S.top == MaxSize - 1)
        return false;									//栈满
    S.data[++S.top] = t;
    return true;
}
bool Pop(SqStack &S, char &x) {
    if (S.top == -1)
        return false;									//栈空
    x = S.data[S.top--];
    return true;
}
bool StackEmpty(SqStack S) {
    return S.top==-1;
}
bool bracketCheck(char *str, int length) {
    SqStack S;
    InitStack(S);
    for (int i = 0; i <length ; i++) {
        if (str[i]=='('||str[i]=='['||str[i]=='{'){
            Push(S,str[i]);
        } else{
            //这里是建立在整个字符串都是由扩号组成的基础上进行的
            //也就是如下逻辑不能过滤字符串中的非括号字符
            if (StackEmpty(S))
                return false;						//扫描到右括号且当前栈空，匹配失败
            char topElem;
            Pop(S,topElem);							//栈顶元素出栈
            if (str[i]==')' && topElem!='(')
                return false;
            if(str[i]==']'&&topElem!='[')
                return false;
            if(str[i]=='}'&&topElem!='{')
                return false;
        }
    }
    return StackEmpty(S);					//最后检查栈，若空匹配成功，非空匹配失败
}
```

##### 表达式求值

后缀表达式（逆波兰表达式）、前缀表达式（波兰表达式）

`中缀表达式转后缀（机算）`

①遇到操作数，直接加入后缀表达式

②遇到' ( '，直接入栈；

​	 遇到' ) '，则依次弹出栈内运算符并加入后缀表达式，直到弹出' ( '为止（左括号不加入）

③遇到运算符，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式

​	 若遇到左括号或栈空则停止，之后再把当前运算符入栈

$((15\div(7-(1+1)))\times3)-(2+(1+1)) \Rightarrow 15711+-\div3\times211++$

`其他`

栈和队列是一种操作==受限的线性表==

### 第5章 树与二叉树

#### 树

##### 概念

`树的路径长度`  指从树根到每个结点的路径长度的总和

`结点的度`  每个结点的<u>分支数</u>

`树的度`  树中结点的__最大__度数

`分支结点`  度大于0的结点，也称<u>非终端结点</u>

`叶子结点`  度为0的结点，也称<u>终端结点</u>

`有序树`  树中结点的各子树从左到右是有次序的，不能互换

|           度为m的树           |         m叉树         |
| :---------------------------: | :-------------------: |
|    ==至少有一个结点度为m==    | 允许所有结点度都小于m |
| 一定是非空树，至少有m+1个结点 |    ==可以是空树==     |

##### 性质

* 对于任意一颗结点数为n的二叉树，高度可能为$\lfloor log_2n \rfloor+1$ ~ n 
* 树的结点数等于所有结点的度数之和（即树的分支数）加1 
* ==度为m的树（或m叉树）中第 i 层上至多有$m^{i-1}$个结点==
* ==高度为h、度为m的树至少有$h+m-1$ 个结点==
* ==高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点，至少有h个结点==
* ==具有n个结点的m叉树的最小高度为$log_m(n(m-1)+1)$​== 

#### 二叉树

##### 定义

 ①每个结点至多只有两颗子树 ②子树有左右之分，其次序不能任意颠倒

##### 性质

* 非空二叉树的叶子结点数等于度为2的结点数加1，即$n_0=n_2+1$ （由$n_0=n_2+1 \Rightarrow n_0+n_2$ 一定是奇数 ）

##### 存储结构

`顺序存储`  只适合存储完全二叉树、满二叉树

`链式存储`  在含有n个结点的二叉链表中共有n+1个空链域（即只有n-1个实际被用到）

```c
#include <stdio.h>
#include <stdlib.h>

struct ElemType {
    int value;
};

typedef struct BiTNode {
    ElemType data;												//数据域
    struct BiTNode *lchild, *rchild;							//左右孩子指针
} BiTNode, *BiTree;

//初始化
void InitTree(BiTree root) {
    root = (BiTree) malloc(sizeof(BiTNode));
    root->data = {1};
    root->lchild = NULL;
    root->rchild = NULL;
}

//插入新结点
bool InsertNode(BiTree T, ElemType val) {
    BiTNode *p = (BiTNode *) malloc(sizeof(BiTNode));
    p->data = val;
    p->lchild = NULL;
    p->rchild = NULL;
    T->lchild = p;												//作为左孩子
}

//访问函数
void visit(BiTree T) {
    printf("%d", T->data.value);
}

//先序遍历
void PreOder(BiTree T) {
    if (T != NULL) {
        visit(T);												//访问根节点
        PreOder(T->lchild);										//遍历左子树
        PreOder(T->rchild);										//遍历右子树
    }
}

//中序遍历
void InOrder(BiTree T) {
    if (T != NULL) {
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}

//后序遍历
void PostOder(BiTree T) {
    if (T != NULL) {
        PostOder(T->lchild);
        PostOder(T->rchild);
        visit(T);
    }
}

//用于层序遍历的辅助队列
typedef struct LinkNode {
    BiTNode *data;												//存的是指针而非结点
    struct LinkNode *next;
} LinkNode;

typedef struct {
    LinkNode *front, *rear;										//队头队尾
} LinkQueue;

// 初始化辅助队列
void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = (LinkNode *) malloc(sizeof(LinkNode));
    //初始化时，front 、rear 都指向头节点
    Q.front->next = NULL;
}

// 入队
bool EnQueue(LinkQueue &Q, BiTNode *x) {
    //判满？链式存储一般不需要判满，除非内存不足
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    if (s == NULL)return false;
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;											//新节点插入到rear之后
    Q.rear = s;													//修改表尾指针
    return true;
}

// 出队
bool DeQueue(LinkQueue &Q, BiTNode *x) {
    if (Q.front == Q.rear)return false;							//队空
    LinkNode *p = Q.front->next;								//用指针p记录队头元素
    x = p->data;												//用x变量返回队头元素
    Q.front->next = p->next;									//修改头节点的next指针
    if (Q.rear == p)											//此次是最后一个节点出队
        Q.rear = Q.front;										//修改rear指针，思考一下为什么？
    free(p); 													//释放节点空间
    return true;
}

bool isEmpty(LinkQueue Q) {
    return Q.front == Q.rear ? true : false;
}

//层序遍历
void levelOrder(BiTree T) {
    LinkQueue Q;
    InitQueue(Q);
    BiTree p;
    EnQueue(Q, T);												// 根结点入队
    while (!isEmpty(Q)) {
        DeQueue(Q, p);											//队头结点出队
        visit(p);
        if (p->lchild != NULL)
            EnQueue(Q, p->lchild);
        if (p->rchild != NULL)
            EnQueue(Q, p->rchild);
    }
}
```

##### 满二叉树

①含有$2^h-1$ 个结点（h为高度）

②对于编号为i的结点（根结点编号为1），

​	若有双亲，则双亲为$i/2$；

​	若有左孩子，则左孩子为$2i$；

​	若有右孩子，则右孩子为$2i+1$；

③只有最后一层有叶子结点

##### 完全二叉树

`定义`  

如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树

`性质`

* 只有最后两层可能有叶子结点

* 1~h-1层为满二叉树

* 最后一个分支结点的序号为$\frac{n}{2} \Rightarrow $ 叶结点数比非叶结点数多1或二者相等 

* 若有度为1的结点，则只可能有==一个==（即$n_1$=0或1），且该结点只有__左孩子__无右孩子

* 若$i\leq\frac{n}{2}$ ，则结点i为分支结点，否则为叶子结点

* 对于编号为i的结点（根结点编号为1），

    若有双亲，则双亲为$i/2$；

    若有左孩子，则左孩子为$2i$；

    若有右孩子，则右孩子为$2i+1$；

* 若完全二叉树有2k个结点，则必有$n_1=1,n_0=k,n_2=k-1$，

    若完全二叉树有2k-1个结点，则必有$n_1=0,n_0=k,n_2=k-1$ 

    （$n_i$ 为度为i的结点数）

* 具有n个结点的完全二叉树的高度为$log_2(n+1)或\lfloor log_2n \rfloor+1$

* 满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树

#### 平衡二叉树

简称平衡树，AVL树

`定义`  树上任一结点的左子树和右子树的深度之差不超过1



#### 二叉排序树 

也称二叉查找树，__BST__（Binary Search Tree）

`定义`  左子树上所有结点的关键字均小于根结点的关键字；

​				右子树的所有结点的关键字均大于根结点的关键字

`删除操作`

* 若被删除结点是叶结点，则直接删除
* 若结点只有一颗左子树或右子树，则让该结点的子树替代该结点
* 若结点有左右子树，则令该结点的直接后继或直接前驱替代该结点

`查找效率`

主要取决于树的高度

* 若该树是平衡二叉树，则平均查找长度为$O(log_2n)$
* 若该树是一个只有右（左）孩子的单支树（类似于有序的单链表），平均查找长度为$O(n)$



### 排序

**稳定性**：关键字相同的元素经过排序后相对顺序是否会改变

#### 插入排序

**定义**：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成

**算法稳定性**：==稳定==

```c
// 直接插入排序
void InsertSort(int A[], int n) {
    int i,j,temp;
    for (i=1; i<n; i++) {
        if (A[i] < A[i-1]) {
            temp = A[i];
            for (j=i-1; j>=0 && A[j]>temp; --j) // j指向i的前一个元素
                A[j+1] = A[j]; 					// 被比较的元素往后挪
            A[j+1] = temp;						// 此处的j+1是为了抵消循环的--j
        }
    }
}
```

```c
// 直接插入排序（带哨兵）
void InsertSort(int A[], int n) {
    int i,j;
    for (i=2; i<=n; i++) {
        if (A[i] < A[i-1]) {
            A[0] = A[i];
            for (j=i-1; A[j]>A[0]; --j) 		// j指向i的前一个元素
                A[j+1] = A[j]; 					// 被比较的元素往后挪
            A[j+1] = A[0];						// 此处的j+1是为了抵消循环的--j
        }
    }
}
```

```c
// 折半插入排序（带哨兵）
void InsertSort(int A[], int n) {
    int i,j,low,high,mid;
    for (i=2; i<=n; i++) {
        A[0] = A[i];
        low = 1; high = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (A[mid] > A[0])
                high = mid - 1;
            else
                low = mid + 1;
        }
        for (j=i-1; j>=high+1; --j)		// 将[low, i-1]的元素统一后移，故这里high+1是不是也可以写成low呢？
            A[j+1] = A[j];
        A[high+1] = A[0];				// 将哨兵元素插入到low位置
    }
}
```

<img src="数据结构.assets/截屏2022-04-25 21.18.17.png" alt="截屏2022-04-25 21.18.17" style="zoom:50%;" />

#### 冒泡排序

**稳定性**：==稳定==

```c
// 冒泡排序
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
void BubbleSort(int A[], int n) {
    for (int i=0; i<n-1; i++) {					// 即到只遍历到倒二个元素
        bool flag = false;						// 表示本躺冒泡是否发生交换的标志
        for (int j=n-1; j>i; j--) {				// j从最后一个元素开始
            if (A[j-1] > A[j]){					// 只有前面的元素大于后面的元素才发生交换
                swap(A[j-1], A[j]);
                flag = true;
            }
        }
        if (flag = false)
            return;								// 本躺遍历没有发生交换，因为后面的元素比当前元素大
        										// 而前面的元素又比当前小，则说明已经有序
    }
}
```

#### 希尔排序

先将表根据增量d分割成若干个子表，对各个子表分别进行直接插入排序；缩小增量，重复上述过程，直到d=1

```c
// 希尔排序
void ShellSort(int A[], int n) {
    int d, i, j;
    for (d=n/2; d>=1; d=d/2) {				// 每一次循环都划分一次子表
        for (i=d+1; i<=n; ++i) {			// i初始化为每个子表第二个元素的位置
            if (A[i] < A[i-d]) {
                A[0] = A[i]					// A[0]只是暂存单元，不是哨兵
                for (j=i-d; )
            }
        }
    }
}
```





[^1]:即通过首地址和元素序号可在时间O(1)内找到指定的元素
[^2]: 即每个结点只存储数据元素
[^3]: 即带头结点时，不管是否为空链，头指针都指向头结点
