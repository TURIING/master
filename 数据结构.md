### 第2章 线性表

`定义`  具有==相同数据类型==的n个数据元素的==有限序列==  

`性质`  

* 除第一个元素外，每个元素有且仅有一个直接前驱；

    除最后一个元素外，每个元素有且仅有一个直接后继

`其他`  

* 线性表中元素的位序是从1开始的，而数组中元素的下标是从0开始的

* |       顺序存储       |   链式存储   |
    | :------------------: | :----------: |
    | 可随机存取、顺序存取 | 只能顺序存取 |

#### 顺序表示

又称__顺序表__

`特点`  ==随机访问==[^1]、==存储密度高==[^2]

`性质`

* 在第$i（1\leq i \leq n）$个结点后插入一个结点，需要后移$n-i$ 个结点，时间复杂度为O(n)

##### 代码实现

`静态分配`

```c
#define MaxSize 10

typedef struct {
	int data[MaxSize];
    int length;
}SqList;

//初始化
void InitList(SqList &L);
//插入
bool ListInsert(SqList &L, int i, int e);
//删除
bool ListDelete(SqList &L, int i, int &e);
//按位查找
int GetElem(SqList L, int i);
//按值查找
int LocateElem(SqList L, int e);

void InitList(SqList &L) {
    for(int i=0; i<MaxSize; i++) {
        L.data[i] = 0;
    }
    L.length = 0;
}

/*
 *	i: 插入的索引
 *	e: 插入的元素
 */
bool ListInsert(SqList &L, int i, int e) {
    //判断索引是否合法
	if (i<1 || i>L.length+1)
        return false;
    //判断表满
    if (L.length >= MaxSize)
        return false;
    //后面的元素后移
    for (int j=L.length; j>=i; j--) {
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = e;
    L.length++;
    return true;
}
/*
 *	i: 删除的索引
 *	e: 删除的元素
 */
bool ListDelete(SqList &L, int i, int &e) {
    if (i<0 || i>L.length)
        return false;
    //取出被删除的元素
    e = L.data[i-1];
    for (int j=i; j<=L.length; j++) {
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}

int GetElem(SqList L, int i) {
    //判断是否越界
    if (i<0 || i>L.length)
        return -1;
    return L.data[i-1];
}

int LocateElem(SqList L, int e) {
    //循环查找
    for (int i=0; i<L.length; i++) {
        if (L.data[i] == e)
            return i+1; //返回位序
    }
    return -1;
}
```

`动态分配`

```c
//默认的最大长度
#define InitSize 10

typedef struct {
    int *data;
    //顺序表的最大容量
    int MaxSize;
    //顺序表当前的长度
    int length;
}SeqList;

//初始化
bool InitList(SeqList &L);
//动态拓展空间
void IncreaseSize(SeqList &L, int len);
//判空
bool Empty(SeqList L);
//判满
bool Full(SeqList L);
//插入
bool ListInsert(SeqList &L, int i, int e);
//删除
bool ListDelete(SeqList &L, int i, int &e);
//按位查找
int GetElem(SeqList L, int i);
//按值查找
int LocateElem(SeqList L, int e);

bool InitList(SeqList &L) {
    L.data = =(int *)malloc(InitSize * sizeof(int));
    if (L.data == NULL)
        return false;
    L.length = 0;
    L.MaxSize = InitSize;
    return true;
}

void IncreaseSize(SeqList &L, int len) {
    int *p = L.data;
    L.data = (int *)malloc(InitSize + len) * sizeof(int));
    //转移旧数据
    for (int i=0; i<L.length; i++) {
        L.data[i] = p[i];
    }
    L.MaxSize = L.MaxSize + len;
    free(p);
}

bool Empty(SeqList L) {
    return (L.length == 0);
}

bool Full(SeqList L) {
    return (L.length >= L.MaxSize);
}

bool ListInsert(SeqList &L, int i, int e) {
    //判断插入的位置是否合法
    if (i<1 || i>L.length+1)
        return false;
    //判断表满
    if (Full(L))
        return false;
    //后面的元素后移
    for (int j=L.length; j>=i; j--) {
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = e;
    L.length++;
    return true;
}

bool ListDelete(SeqList &L, int i, int &e) {
    //判断i的位置是否合法
    if (i < 0 || i > L.length)
        return false;
    //取出将要被删除的数
    e = L.data[i-1];
    for (int j=i; j<=L.length; j++) {
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}

int GetElem(SeqList L, int i) {
    //判断是否越界
    if (i<0 || i>L.length)
        return -1;
    return L.data[i-1];
}

int LocateElem(SeqList L, int e) {
    //循环查找
    for (int i=0; i<L.length; i++) {
        if (L.data[i] == e)
            //返回位序
            return i+1; 
    }
    return -1;
}
```

#### 链式表示

又称__单链表__

##### 静态链表

`指针`  指结点的相对地址（==数组下标==），又称游标

`注意`

* 静态链表也需要__预先分配__一块连续的内存空间
* 静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而__不需要__移动元素

`其他`

* 头结点与头指针的区分：

    ①不管带不带头结点，头指针始终指向链表的第一个结点[^3]

    ②头结点是带头结点的链表中第一个结点，结点内通常不存储信息

* 引入头结点的优点：

    ①由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的

    ​	 操作和在表的其他位置上的操作一样，无须进行特殊处理

    ②无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空），

    ​	 因此空表和非空表的处理也就得到了统一

##### 代码实现

###### 单链表

`不带头结点`

```c
typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

//初始化
bool InitList(LinkList &L);
//判断是否为空
bool Empty(LinkList L);


bool InitList(LinkList &L) {
    L = NULL;
    return true;
}

bool Empty(LinkList L) {
    return (L == NULL);
}
```

`带头结点`

```c
typedef struct LNode {
    int data;
    LNode *next;
} LNode, *LinkList;

//初始化
bool InitList(LinkList &L);
//判空
bool Empty(LinkList L);

bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
}

bool Empty(LinkList L) {
    return (L->next == NULL);
}
```



### 第3章 栈和队列

#### 栈

`概念`

__栈顶__: 进行插入删除的那一端

__栈底__: 不允许插入和删除的另一端

__特性__: 后进先出

`性质`

* n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C_{2n}^n$

`共享栈`

* top0=-1时，0号栈为空；top1=MaxSize时，1号栈为空；

* top1-top0=1时，栈满
* 共享栈是为了更有效的利用存储空间

`栈的链式存储结构`

通常采用单链表实现，所有操作都是在单链表的==表头==进行的

__优点__: 便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况

#### 队列

`概念`

__队头__: 允许删除的一端

__队尾__: 允许插入的一端

`特性`

先进先出

`顺序存储结构`

队头指针front指向队头元素；队尾指针指向队尾元素的下一个位置

__队空条件__: Q.front == Q.rear == 0

#### 栈和队列的应用

##### 表达式求值

`中缀表达式转后缀（机算）`

①遇到操作数，直接加入后缀表达式

②遇到' ( '，直接入栈；

​	 遇到' ) '，则依次弹出栈内运算符并加入后缀表达式，直到弹出' ( '为止（左括号不加入）

③遇到运算符，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式

​	 若遇到左括号或栈空则停止，之后再把当前运算符入栈

$((15\div(7-(1+1)))\times3)-(2+(1+1)) \Rightarrow 15711+-\div3\times211++$

`其他`

栈和队列是一种操作==受限的线性表==

### 第5章 树与二叉树

#### 树

##### 概念

`树的路径长度`  指从树根到每个结点的路径长度的总和

`结点的度`  每个结点的<u>分支数</u>

`树的度`  树中结点的__最大__度数

`分支结点`  度大于0的结点，也称<u>非终端结点</u>

`叶子结点`  度为0的结点，也称<u>终端结点</u>

`有序树`  树中结点的各子树从左到右是有次序的，不能互换

|           度为m的树           |         m叉树         |
| :---------------------------: | :-------------------: |
|    ==至少有一个结点度为m==    | 允许所有结点度都小于m |
| 一定是非空树，至少有m+1个结点 |    ==可以是空树==     |

##### 性质

* 对于任意一颗结点数为n的二叉树，高度可能为$\lfloor log_2n \rfloor+1$ ~ n 
* 树的结点数等于所有结点的度数之和（即树的分支数）加1 
* ==度为m的树（或m叉树）中第 i 层上至多有$m^{i-1}$个结点==
* ==高度为h、度为m的树至少有$h+m-1$ 个结点==
* ==高度为h的m叉树至多有$(m^h-1)/(m-1)$个结点，至少有h个结点==
* ==具有n个结点的m叉树的最小高度为$log_m(n(m-1)+1)$​== 

#### 二叉树

##### 定义

 ①每个结点至多只有两颗子树 ②子树有左右之分，其次序不能任意颠倒

##### 性质

* 非空二叉树的叶子结点数等于度为2的结点数加1，即$n_0=n_2+1$ （由$n_0=n_2+1 \Rightarrow n_0+n_2$ 一定是奇数 ）

##### 存储结构

`顺序存储`  只适合存储完全二叉树、满二叉树

`链式存储`  在含有n个结点的二叉链表中共有n+1个空链域（即只有n-1个实际被用到）

```c
#include <stdio.h>
#include <stdlib.h>

struct ElemType {
    int value;
};

typedef struct BiTNode {
    ElemType data;												//数据域
    struct BiTNode *lchild, *rchild;							//左右孩子指针
} BiTNode, *BiTree;

//初始化
void InitTree(BiTree root) {
    root = (BiTree) malloc(sizeof(BiTNode));
    root->data = {1};
    root->lchild = NULL;
    root->rchild = NULL;
}

//插入新结点
bool InsertNode(BiTree T, ElemType val) {
    BiTNode *p = (BiTNode *) malloc(sizeof(BiTNode));
    p->data = val;
    p->lchild = NULL;
    p->rchild = NULL;
    T->lchild = p;												//作为左孩子
}

//访问函数
void visit(BiTree T) {
    printf("%d", T->data.value);
}

//先序遍历
void PreOder(BiTree T) {
    if (T != NULL) {
        visit(T);												//访问根节点
        PreOder(T->lchild);										//遍历左子树
        PreOder(T->rchild);										//遍历右子树
    }
}

//中序遍历
void InOrder(BiTree T) {
    if (T != NULL) {
        InOrder(T->lchild);
        visit(T);
        InOrder(T->rchild);
    }
}

//后序遍历
void PostOder(BiTree T) {
    if (T != NULL) {
        PostOder(T->lchild);
        PostOder(T->rchild);
        visit(T);
    }
}

//用于层序遍历的辅助队列
typedef struct LinkNode {
    BiTNode *data;												//存的是指针而非结点
    struct LinkNode *next;
} LinkNode;

typedef struct {
    LinkNode *front, *rear;										//队头队尾
} LinkQueue;

// 初始化辅助队列
void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = (LinkNode *) malloc(sizeof(LinkNode));
    //初始化时，front 、rear 都指向头节点
    Q.front->next = NULL;
}

// 入队
bool EnQueue(LinkQueue &Q, BiTNode *x) {
    //判满？链式存储一般不需要判满，除非内存不足
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    if (s == NULL)return false;
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;											//新节点插入到rear之后
    Q.rear = s;													//修改表尾指针
    return true;
}

// 出队
bool DeQueue(LinkQueue &Q, BiTNode *x) {
    if (Q.front == Q.rear)return false;							//队空
    LinkNode *p = Q.front->next;								//用指针p记录队头元素
    x = p->data;												//用x变量返回队头元素
    Q.front->next = p->next;									//修改头节点的next指针
    if (Q.rear == p)											//此次是最后一个节点出队
        Q.rear = Q.front;										//修改rear指针，思考一下为什么？
    free(p); 													//释放节点空间
    return true;
}

bool isEmpty(LinkQueue Q) {
    return Q.front == Q.rear ? true : false;
}

//层序遍历
void levelOrder(BiTree T) {
    LinkQueue Q;
    InitQueue(Q);
    BiTree p;
    EnQueue(Q, T);												// 根结点入队
    while (!isEmpty(Q)) {
        DeQueue(Q, p);											//队头结点出队
        visit(p);
        if (p->lchild != NULL)
            EnQueue(Q, p->lchild);
        if (p->rchild != NULL)
            EnQueue(Q, p->rchild);
    }
}
```

##### 满二叉树

①含有$2^h-1$ 个结点（h为高度）

②对于编号为i的结点（根结点编号为1），

​	若有双亲，则双亲为$i/2$；

​	若有左孩子，则左孩子为$2i$；

​	若有右孩子，则右孩子为$2i+1$；

③只有最后一层有叶子结点

##### 完全二叉树

`定义`  

如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树

`性质`

* 只有最后两层可能有叶子结点

* 1~h-1层为满二叉树

* 最后一个分支结点的序号为$\frac{n}{2} \Rightarrow $ 叶结点数比非叶结点数多1或二者相等 

* 若有度为1的结点，则只可能有==一个==（即$n_1$=0或1），且该结点只有__左孩子__无右孩子

* 若$i\leq\frac{n}{2}$ ，则结点i为分支结点，否则为叶子结点

* 对于编号为i的结点（根结点编号为1），

    若有双亲，则双亲为$i/2$；

    若有左孩子，则左孩子为$2i$；

    若有右孩子，则右孩子为$2i+1$；

* 若完全二叉树有2k个结点，则必有$n_1=1,n_0=k,n_2=k-1$，

    若完全二叉树有2k-1个结点，则必有$n_1=0,n_0=k,n_2=k-1$ 

    （$n_i$ 为度为i的结点数）

* 具有n个结点的完全二叉树的高度为$log_2(n+1)或\lfloor log_2n \rfloor+1$

* 满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树

#### 平衡二叉树

简称平衡树，AVL树

`定义`  树上任一结点的左子树和右子树的深度之差不超过1



#### 二叉排序树 

也称二叉查找树，__BST__（Binary Search Tree）

`定义`  左子树上所有结点的关键字均小于根结点的关键字；

​				右子树的所有结点的关键字均大于根结点的关键字

`删除操作`

* 若被删除结点是叶结点，则直接删除
* 若结点只有一颗左子树或右子树，则让该结点的子树替代该结点
* 若结点有左右子树，则令该结点的直接后继或直接前驱替代该结点

`查找效率`

主要取决于树的高度

* 若该树是平衡二叉树，则平均查找长度为$O(log_2n)$
* 若该树是一个只有右（左）孩子的单支树（类似于有序的单链表），平均查找长度为$O(n)$



### 排序

**稳定性**：关键字相同的元素经过排序后相对顺序是否会改变

#### 插入排序

**定义**：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成

**算法稳定性**：==稳定==

```c
// 直接插入排序
void InsertSort(int A[], int n) {
    int i,j,temp;
    for (i=1; i<n; i++) {
        if (A[i] < A[i-1]) {
            temp = A[i];
            for (j=i-1; j>=0 && A[j]>temp; --j) // j指向i的前一个元素
                A[j+1] = A[j]; 					// 被比较的元素往后挪
            A[j+1] = temp;						// 此处的j+1是为了抵消循环的--j
        }
    }
}
```

```c
// 直接插入排序（带哨兵）
void InsertSort(int A[], int n) {
    int i,j;
    for (i=2; i<=n; i++) {
        if (A[i] < A[i-1]) {
            A[0] = A[i];
            for (j=i-1; A[j]>A[0]; --j) 		// j指向i的前一个元素
                A[j+1] = A[j]; 					// 被比较的元素往后挪
            A[j+1] = A[0];						// 此处的j+1是为了抵消循环的--j
        }
    }
}
```

```c
// 折半插入排序（带哨兵）
void InsertSort(int A[], int n) {
    int i,j,low,high,mid;
    for (i=2; i<=n; i++) {
        A[0] = A[i];
        low = 1; high = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (A[mid] > A[0])
                high = mid - 1;
            else
                low = mid + 1;
        }
        for (j=i-1; j>=high+1; --j)		// 将[low, i-1]的元素统一后移，故这里high+1是不是也可以写成low呢？
            A[j+1] = A[j];
        A[high+1] = A[0];				// 将哨兵元素插入到low位置
    }
}
```

<img src="数据结构.assets/截屏2022-04-25 21.18.17.png" alt="截屏2022-04-25 21.18.17" style="zoom:50%;" />

#### 冒泡排序

**稳定性**：==稳定==

```c
// 冒泡排序
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
void BubbleSort(int A[], int n) {
    for (int i=0; i<n-1; i++) {					// 即到只遍历到倒二个元素
        bool flag = false;						// 表示本躺冒泡是否发生交换的标志
        for (int j=n-1; j>i; j--) {				// j从最后一个元素开始
            if (A[j-1] > A[j]){					// 只有前面的元素大于后面的元素才发生交换
                swap(A[j-1], A[j]);
                flag = true;
            }
        }
        if (flag = false)
            return;								// 本躺遍历没有发生交换，因为后面的元素比当前元素大
        										// 而前面的元素又比当前小，则说明已经有序
    }
}
```

#### 希尔排序

先将表根据增量d分割成若干个子表，对各个子表分别进行直接插入排序；缩小增量，重复上述过程，直到d=1

```c
// 希尔排序
void ShellSort(int A[], int n) {
    int d, i, j;
    for (d=n/2; d>=1; d=d/2) {				// 每一次循环都划分一次子表
        for (i=d+1; i<=n; ++i) {			// i初始化为每个子表第二个元素的位置
            if (A[i] < A[i-d]) {
                A[0] = A[i]					// A[0]只是暂存单元，不是哨兵
                for (j=i-d; )
            }
        }
    }
}
```





[^1]:即通过首地址和元素序号可在时间O(1)内找到指定的元素
[^2]: 即每个结点只存储数据元素
[^3]: 即带头结点时，不管是否为空链，头指针都指向头结点
