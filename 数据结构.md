### 第2章 线性表

`定义`  具有==相同数据类型（每个数据元素所占空间一样大）==的n个数据元素的==有限序列==  

`性质`  

* 除第一个元素外，每个元素有且仅有一个直接前驱；

    除最后一个元素外，每个元素有且仅有一个直接后继

`其他`  

* 线性表中元素的**位序是从1开始的**，而数组中元素的下标是从0开始的

* **链式存储结构比顺序结构更能方便地表示各种逻辑结构**

* **设有尾指针的单链表执行删除最后一个元素的操作与链表长度有关**

* |         顺序存储         |     链式存储     |
    | :----------------------: | :--------------: |
    | ==可随机存取、顺序存取== | ==只能顺序存取== |

#### 顺序表示

又称__顺序表__

`特点`  ==随机访问==[^1]、==存储密度高==[^2]、==拓展容量不方便==、==插入、删除操作不方便，需要移动大量元素==

`性质`

* 在第$i（1\leq i \leq n）$个结点后插入一个结点，==需要后移$n-i$ 个结点==，时间复杂度为O(n)

##### 代码实现

`静态分配`

```c
#define MaxSize 10

typedef struct {
	int data[MaxSize];
    int length;
}SqList;

void InitList(SqList &L) {
    for(int i=0; i<MaxSize; i++) {
        L.data[i] = 0;
    }
    L.length = 0;
}
/*
 *	i: 插入的位序（需区别于数组的下标）
 *	e: 插入的元素
 */
bool ListInsert(SqList &L, int i, int e) {
    //判断索引是否合法
	if (i<1 || i>L.length+1)
        return false;
    //判断表满
    if (L.length >= MaxSize)
        return false;
    //后面的元素后移
    for (int j=L.length; j>=i; j--) {
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = e;
    L.length++;
    return true;
}
/*
 *	i: 删除的位序
 *	e: 删除的元素
 */
bool ListDelete(SqList &L, int i, int &e) {
    if (i<0 || i>L.length)
        return false;
    //取出被删除的元素
    e = L.data[i-1];
    for (int j=i; j<=L.length; j++) {
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}
/*
 * i: 位序
 */
int GetElem(SqList L, int i) {
    //判断是否越界
    if (i<0 || i>L.length)
        return -1;
    return L.data[i-1];
}
int LocateElem(SqList L, int e) {
    //循环查找
    for (int i=0; i<L.length; i++) {
        if (L.data[i] == e)
            return i+1; 									//返回位序
    }
    return -1;
}
```

`动态分配`

```c
//默认的最大长度
#define InitSize 10

typedef struct {
    int *data;
    //顺序表的最大容量
    int MaxSize;
    //顺序表当前的长度
    int length;
}SeqList;

bool InitList(SeqList &L) {
    L.data = =(int *)malloc(InitSize * sizeof(int));
    if (L.data == NULL)
        return false;
    L.length = 0;
    L.MaxSize = InitSize;
    return true;
}
void IncreaseSize(SeqList &L, int len) {
    int *p = L.data;
    L.data = (int *)malloc(InitSize + len) * sizeof(int));
    //转移旧数据
    for (int i=0; i<L.length; i++) {
        L.data[i] = p[i];
    }
    L.MaxSize = L.MaxSize + len;
    free(p);
}
bool Empty(SeqList L) {
    return (L.length == 0);
}
bool Full(SeqList L) {
    return (L.length >= L.MaxSize);
}
/*
 *	i: 插入的位序（需区别于数组的下标）
 *	e: 插入的元素
 */
bool ListInsert(SeqList &L, int i, int e) {
    //判断插入的位置是否合法
    if (i<1 || i>L.length+1)
        return false;
    //判断表满
    if (Full(L))
        return false;
    //后面的元素后移
    for (int j=L.length; j>=i; j--) {
        L.data[j] = L.data[j-1];
    }
    L.data[i-1] = e;
    L.length++;
    return true;
}
/*
 *	i: 删除的位序
 *	e: 删除的元素
 */
bool ListDelete(SeqList &L, int i, int &e) {
    //判断i的位置是否合法
    if (i < 0 || i > L.length)
        return false;
    //取出将要被删除的数
    e = L.data[i-1];
    for (int j=i; j<=L.length; j++) {
        L.data[j-1] = L.data[j];
    }
    L.length--;
    return true;
}
int GetElem(SeqList L, int i) {
    //判断是否越界
    if (i<0 || i>L.length)
        return -1;
    return L.data[i-1];
}
int LocateElem(SeqList L, int e) {
    //循环查找
    for (int i=0; i<L.length; i++) {
        if (L.data[i] == e)
            //返回位序
            return i+1; 
    }
    return -1;
}
```

#### 链式表示

`其他`

* **头结点与头指针的区分**：

    ①不管带不带头结点，头指针始终指向链表的第一个结点[^3]

    ②头结点是带头结点的链表中第一个结点，结点内通常不存储信息

* **引入头结点的优点**：

    ①由于第一个数据结点的位置被存放在头结点的指针域中，因此在链表的第一个位置上的

    ​	 操作和在表的其他位置上的操作一样，无须进行特殊处理

    ②无论链表是否为空，其头指针都指向头结点的非空指针（空表中头结点的指针域为空），

    ​	 因此空表和非空表的处理也就得到了统一

##### 单链表

`不带头结点`

```c
typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

bool InitList(LinkList &L) {
    L = NULL;										//空表暂时没有任何数据
    return true;
}
bool Empty(LinkList L) {
    return (L == NULL);
}
bool ListInsert(LinkList &L, int i, int e) {
    if (i < 1)										//判断位序i是否合法
        return false;
    //不带头节点时，插入位置正好为表头时，得单独处理
    if (i = 1) {
        LNode *s = (LNode *) malloc(sizeof(LNode));
        s->data = e;
        s->next = L;			//L是指向第一个结点的指针，故此处将s指向原本的第一个结点
        L = s;										//将s作为第一个结点
        return true;
    }
    LNode *p;
    int j = 0;										//记录p指向的节点的位序
    p = L;											//L指向头节点，从头开始
    while (p != NULL && j < i - 1) {
        //循环扫描
        p = p->next;
        j++;
    }
    if (p == NULL) 									//i值超过表长，不合法
        return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    //下面的顺序不可交换
    s->next = p->next;
    p->next = s;
    return true;
}
```

`带头结点`

```c
typedef struct LNode {
    int data;
    LNode *next;
} LNode, *LinkList;

bool InitList(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL)
        return false;
    L->next = NULL;
    return true;
}
bool Empty(LinkList L) {
    return (L->next == NULL);
}
//按位插入
/*
 * i: 位序
 */
bool ListInsert(LinkList &L, int i, int e) {
    if (i < 1)
        return false;
    LNode *p;
    int j = 0;												//记录p指向的节点的位序
    p = L;													//P指向头节点，从头开始
    while (p != NULL && j < i - 1) {//由于带头，故位序即位置；此处找到i的前一个结点而已
        p = p->next;
        j++;
    }
    if (p == NULL) 					//i的前一个都找不到了，i结点自然不存在，即i值不合法
        return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    //下面的顺序不可交换
    s->next = p->next;
    p->next = s;
    return true;
}
//指定节点的后插操作
bool InsertNextNode(LNode *p, int e) {
    if (p == NULL)
        return false;										//判断指定节点是否存在
    LNode *s = (LNode *) malloc(sizeof(LNode));
    if (s == NULL)
        return false;										//分配内存失败
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
//指定节点的前插操作
//先完成后插，再交换数据以实现前插
bool InsertPriorNode(LNode *p, int e) {
    if (p == NULL)
        return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    if (s == NULL)
        return false;
    s->next = p->next;
    p->next = s;
    s->data = p->data;
    p->data = e;
    return true;
}
//按指定位序删除节点并返回其值
bool ListDelete(LinkList &L, int i, int &e) {
    if (i < 1)
        return false;
    LNode *p;
    int j = 0;
    p = L;
    while (p != NULL && j < i - 1) {					//找到指定结点的前一个结点
        p = p->next;
        j++;
    }
    LNode *q = p->next;
    e = q->data;
    p->next = q->next;
    free(q);
    return true;
}
//删除指定节点
bool DeleteNode(LNode *p) {
	if(p==NULL)
        return false;
    LNode *q = p->next;
    p->data = q->data;									// 交换数据
    p->next=q->next;
    free(q);
    return true;
}
//按位查找，返回第i个元素
LNode *GetElem(LinkList L, int i) {
    if (i<0)
        return NULL;
    LNode *p;
    int j = 0;											//记录p指向的是第几个结点
    p = L;
    while(p!=NULL && j<i) {								//找到第i个结点
        p = p->next;
        j++;        		
    }
    return p;
}
//按值查找
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while(p != NULL && p->data != e)
        p = p->next;
    return p;
}
//返回表长度
int Length(LinkList L) {
    int len = 0;
    LNode *p = L;
    while(p->next != NULL) {
        p = p->next;
        len++;
    }
    return len;
}
//尾插法建立单链表
LinkList List_TailInsert(LinkList &L) {
    int x;
    L = (LinkList)malloc(sizeof(LNode));
    L->next = NULL;
    LNode *s,*r = L;
    scanf("%d", &x);
    while(x!=9999) {
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL;											//置空
    return L;
}
//头插法建立单链表
LinkList List_HeadInsert(LinkList &L) {
    int x;
    L = (LinkList)malloc(sizeof(LNode));
    LNode *s;
    L->next = NULL;
    scanf("%d", &x);
    while(x!=9999) {
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;
        L->next = s;
        scanf("%d", &x);
    }
    return L;
}
```

##### 双链表

```c
//带头节点
typedef struct DNode {
    int data;
    struct DNode *prior, *next;									//前指针和后指针
} DNode, *DLinkList;

//初始化
bool InitDLinkList(DLinkList &L) {
    L = (DNode *) malloc(sizeof(DNode));
    if (L == NULL)
        return false;
    L->prior == NULL;
    L->next == NULL;
    return true;
}
//判空
bool Empty(DLinkList L) {
    return (L->next == NULL);
}
//指定节点的后插操作
bool InsertNextDNode(DNode *p, DNode *s) {
    //注意顺序不可交换
    s->next = p->next;
    if(p->next != NULL)										//判断是否有后继结点
    	p->next->prior = s;
    s->prior = p;
    p->next = s;
    return true;
}
//删除P节点的后继节点
bool DeleteNextNode(DNode *p) {
    if (p == NULL)
        return false;
    DNode *q = p->next;
    if (q == NULL)											//P节点没有后继
        return false;
    p->next = q->next;
    if (q->next != NULL)									//q不是最后一个节点
        q->next->prior = p;
    free(q);
    return true;
}
//销毁整个表
bool DestroyList(DLinkList &L) {    
    while (L->next != NULL)									//循环删除并释放每个节点
        DeleteNextNode(L);
    free(L);
    L = NULL;

}
//从P点向后遍历
bool PrintNextDNode(DNode *p) {
    if (p == NULL)
        return false;
    while (p != NULL) {
        printf("当前节点的值是:%d", p->data);
        p = p->next;
    }
    return true;
}
//从P点向前遍历
bool PrintPriorDNode(DNode *p) {
    if (p == NULL)
        return false;
    while (p != NULL) {
        printf("当前节点的值是:%d", p->data);
        p = p->prior;
    }
    return true;
}
//从P点向前遍历（跳过头节点）
bool PrintPriorDNodeOverHead(DNode *p) {
    if (p == NULL)
        return false;
    while (p->prior != NULL) {
        printf("当前节点的值是:%d", p->data);
        p = p->prior;
    }
    return true;
}
```

##### 循环单链表

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

//初始化一个循环单链表
bool InitRLinkList(LinkList &L){
    L=(LNode *)malloc(sizeof(LNode));
    if (L=NULL)
        return false;
    L->next=L;								//头节点nex指向头节点，以此形成循环链表
    return true;
}
//判断P是不是表尾指针
bool IsTail(LinkList L,LNode *p){
    return (p->next == L);
}
```

##### 循环双链表

```c
typedef struct DNode{
    int data;
    struct DNode *prior,*next;
}DNode,*DLinkList;

//初始化
bool InitRDLinkList(DLinkList &L){
    L=(DNode *)malloc(sizeof(DNode));
    if (L==NULL)
        return false;
    L->prior=L;
    L->next=L;
    return true;
}
//判断节点p是不是循环双链表的表尾节点
bool iTail(DLinkList L,DNode *p){
    return (p->next == L);
}
//在p节点之后插入s节点
bool InsertNextDNode(DNode *p,DNode *s){
    s->next=p->next;
    p->next->prior=s;
    s->prior=p;
    p->next=s;
    return true;
}
//删除操作
bool DeleteNextDNode(DLinkList &L,DNode *p){
    DNode *q = p->next;
    p->next=q->next;
    q->next->prior=p;
    free(q);
    return true;
}
```

##### 静态链表

`指针`  指结点的相对地址（==数组下标==），又称游标

`注意`

* 静态链表也需要==预先分配一块连续的内存空间==

**优点**：==增删改查不需要移动大量元素==

**缺点**：==不能随机存取==、==容量固定不变==

```c
#define MaxSize 10
//第一种定义方法
struct Node0{
    ElemType data;
    int next;											//下一个元素的数组下标
};
//第二种定义方法
typedef struct Node{
    ElemType data;
    int next;
}SLinkList[MaxSize];
```

### 第3章 栈和队列

#### 栈

只允许==在一端==进行插入或删除操作的==线性表==

`概念`

__栈顶__: <u>进行插入删除的那一端</u>

__栈底__: 不允许插入和删除的另一端

__特性__: ==后进先出==

`性质`

* ==n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C_{2n}^n$==

##### 顺序表示

```c
#define MaxSize 10
typedef struct {
    ElemType data[MaxSize];
    int top;													//栈顶指针
} SqStack;

//初始化
void InitStack(SqStack &S) {
    S.top = -1;											//栈顶指针始终指向栈顶元素
}
//入栈
bool Push(SqStack &S, int t) {
    if (S.top == MaxSize - 1)
        return false;											//栈满
    S.top += 1;
    S.data[S.top] = t;
    return true;
}
//出栈,并打印出栈顶元素
bool Pop(SqStack &S, int &x) {
    if (S.top == -1)
        return false;											//栈空
    x = S.data[S.top];
    S.top -= 1;
    return true;
}
//读取栈顶元素
bool GetTop(SqStack S, int &x) {
    if (S.top == -1)
        return false;
    x = S.data[S.top];
    return true;
}
```

```c
#define MaxSize 10
typedef struct {
    ElemType data[MaxSize];
    int top;													//栈顶指针
} SqStack;

//初始化1
void InitStack(SqStack &S) {
    S.top = 0;								//栈顶指针始终会指向栈顶元素的下一空元素
}
//入栈
bool Push(SqStack &S, int t) {
    if (S.top == MaxSize)
        return false;
    S.data[S.top++] = t;
    return true;
}
//出栈
bool Pop(SqStack &S, int &x) {
    if (S.top == 0)
        return false;										//栈空报错，注意判空条件
    x = S.data[--S.top];
    return true;
}
//读取栈顶元素
bool GetTop(SqStack S, int &x) {
    if (S.top == 0)return false;
    x = S.data[S.top - 1];
    return true;
}
```

##### 共享栈

* ==top0 = -1时，0号栈为空；top1 = MaxSize时，1号栈为空；==

* ==top0 + 1 = top1时，栈满==
* ==共享栈是为了更有效的利用存储空间==

```c
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int top0;												//0号栈顶指针
    int top1;												//1号栈顶指针
} ShStack;

//初始化
void InitStack(ShStack &S) {
    S.top0 = -1;
    S.top1 = MaxSize;									//MaxSize就是第二个栈的栈底
}
//入栈
bool Push(ShStack &S, int t) {
    if (S.top0 + 1 == S.top1)
        return false;										//栈满
    S.data[++S.top0] = t;
    return true;
}
//出栈
bool Pop(ShStack &S, int &x) {
    if (S.top0 == -1)
        return false;										//栈空
    x = S.data[S.top0--];
    return true;
}
//读取栈顶元素，栈0
bool GetTop0(ShStack S, int &x) {
    if (S.top0 == -1)
        return false;
    x = S.data[S.top0];
    return true;
}
//读取栈顶元素，栈1
bool GetTop1(ShStack S, int &x) {
    if (S.top1 == MaxSize)
        return false;
    x = S.data[S.top1];
    return true;
}
```

`栈的链式存储结构`

通常采用单链表实现，所有操作都是在单链表的==表头==进行的

__优点__: ==便于多个栈共享存储空间和提高效率，且不存在栈满上溢的情况==

```c
#define MaxSize 10
typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} *LinkStack;

bool InitStack(LinkStack &LS) {
    LS = (LinkNode *) malloc(sizeof(LinkNode));
    if (LS == NULL)
        return false;
    LS->next = NULL;
    return true;
}
bool Push(LinkStack &LS, int t) {
    //入站不需要检查栈满
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    if (s == NULL)
        return false;
    s->data = t;
    s->next = LS->next;
    LS->next = s;
    return true;
}
bool Pop(LinkStack &LS, int &x) {
    if (LS->next == NULL)
        return false;													//栈空
    LinkNode *q;
    q = LS->next;
    LS->next = q->next;
    x = q->data;
    free(q);
    return true;
}
bool GetTop(LinkStack LS, int &x) {
    if (LS == NULL)
        return false;
    x = LS->next->data;
    return true;
}
```

#### 队列

**只允许在一端进行插入，在另一端删除的<u>线性表</u>**

`概念`

__队头__: <u>允许删除的一端</u>

__队尾__: <u>允许插入的一端</u>

**队列长度**：==$$(rear-front+maxsize)\%maxsize$$)==（当队头指针front指向队头元素；队尾指针指向队尾元素的下一个位置时）

`特性`

==先进先出==

##### 顺序存储

==队头指针front指向队头元素；队尾指针指向队尾元素的下一个位置==

__队空条件__: Q.front == Q.rear == 0

```c
//第一种实现
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int front, rear;
} SqQueue;

void InitQueue(SqQueue &Q) {
    Q.rear = Q.front = 0;
}
bool QueueEmpty(SqQueue Q) {
    return Q.front == Q.rear;
}
bool EnQueue(SqQueue &Q, int t) {
    //因为判空条件为rear、front指向同一位置，故判满只能牺牲一个空间，所以rear+1
    if ((Q.rear + 1) % MaxSize == Q.front)
        return false;												//队满
    Q.data[Q.rear] = t;
    Q.rear = (Q.rear + 1) % MaxSize;				//通过取余操作让整个队列循环起来
    return true;
}
bool DeQueue(SqQueue &Q, int &x) {
    if (Q.rear == Q.front)
        return false;												//队空
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize;
    return true;
}
bool GetHead(SqQueue Q, int &x) {
    if (Q.front == Q.rear)
        return false;
    x = Q.data[Q.front];
    return true;
}
```

```c
//第二种实现
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int front, rear;
    int size;							//利用size变量记录队列长度，并用作判满的条件
} SqQueue;

void InitQueue(SqQueue &Q) {
    Q.rear = Q.front = 0;
    Q.size = 0;										//初始长度
}
bool QueueEmpty(SqQueue Q) {
    return Q.size == 0;
}
bool EnQueue(SqQueue &Q, int t) {
    if (Q.size == MaxSize)
        return false;								//队满
    Q.data[Q.rear] = t;
    Q.rear = (Q.rear + 1) % MaxSize;				//通过取余操作让整个队列循环起来
    Q.size++;
    return true;
}
bool DeQueue(SqQueue &Q, int &x) {
    if (Q.size == 0)
        return false;								//队空
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize;
    Q.size--;
    return true;
}
bool GetHead(SqQueue Q, int &x) {
    if (Q.size == 0)return false;
    x = Q.data[Q.front];
    return true;
}
```

```c
//第三种实现
#define MaxSize 10
typedef struct {
    int data[MaxSize];
    int front,rear;
    int tag;		//利用tag变量记录最后一次操作是什么，0为删除，1为插入,并用作判满的条件
}SqQueue;

void InitQueue(SqQueue &Q) {
    Q.rear=Q.front=0;
    Q.tag=0;										//初始化最后一次的操作状态
}
bool QueueEmpty(SqQueue Q) {
    return Q.front==Q.rear && Q.tag==0;				//只有删除操作，才可能导致队空
}
bool EnQueue(SqQueue &Q, int t) {
    if(Q.front==Q.rear&&Q.tag==1)
        return false;								//只有插入操作，才可能导致队满
    Q.data[Q.rear]=t;
    Q.rear=(Q.rear+1)%MaxSize;
    Q.tag=1;
    return true;
}
bool DeQueue(SqQueue &Q, int &x) {
    if(Q.rear==Q.front&&Q.tag==0)
        return false;								//队空
    x=Q.data[Q.front];
    Q.front=(Q.front+1)%MaxSize;
    Q.tag==0;
    return true;
}
bool GetHead(SqQueue Q, int &x) {
    if (Q.rear==Q.front&&Q.tag==0)
        return false;
    x=Q.data[Q.front];
    return true;
}
```

##### 链式存储

==队头设置在链头，队尾设置在链尾==

```c
//链式队列（带头节点）
typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} LinkNode;
typedef struct {
    LinkNode *front, *rear;
} LinkQueue;

void InitQueue(LinkQueue &Q) {
    //初始化时，front 、rear 都指向头节点
    Q.front = Q.rear = (LinkNode *) malloc(sizeof(LinkNode));
    Q.front->next = NULL;
}
bool EnQueue(LinkQueue &Q, int x) {
    //不需要判满
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    if (s == NULL)
        return false;
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;									//新节点插入到rear之后
    Q.rear = s;											//修改表尾指针
    return true;
}
bool DeQueue(LinkQueue &Q, int &x) {
    if (Q.front == Q.rear)
        return false;									//队空
    LinkNode *p = Q.front->next;						//用指针p记录队头元素
    x = p->data;										//用x变量返回队头元素
    Q.front->next = p->next;							//修改头节点的next指针
    if (Q.rear == p)									//此次是最后一个节点出队
        Q.rear = Q.front;								//修改rear指针
    free(p);
    return true;
}
bool GetHead(LinkQueue Q, int &x) {
    if (Q.front == Q.rear)
        return false;									//队空
    x = Q.front->next->data;							//用x变量返回队头元素
    return true;
}
bool QueueEmpty(LinkQueue Q) {
    return Q.front == Q.rear;
}
```

```c
//链式队列（不带头节点）
typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} LinkNode;
typedef struct {
    LinkNode *front, *rear;
} LinkQueue;

void InitQueue(LinkQueue &Q) {
    Q.front = Q.rear = NULL;
}
bool EnQueue(LinkQueue &Q, int x) {
    LinkNode *s = (LinkNode *) malloc(sizeof(LinkNode));
    if (s == NULL)
        return false;
    s->data = x;
    s->next = NULL;
    if (Q.front == NULL) {
        Q.rear = Q.front = s;						//插入第一个元素时，需要做特殊处理
    } else {
        Q.rear->next = s;									//新节点插入到rear之后
        Q.rear = s;											//修改表尾指针
    }
    return true;
}
bool DeQueue(LinkQueue &Q, int &x) {
    if (Q.front == NULL)
        return false;										//队空
    LinkNode *p = Q.front;									//用指针p记录队头元素
    x = p->data;											//用x变量返回队头元素
    Q.front = p->next;										//修改头节点的next指针
    if (Q.rear == p)										//此次是最后一个节点出队
        Q.rear = Q.front = NULL;
    free(p);
    return true;
}
bool GetHead(LinkQueue Q, int &x) {
    if (Q.front == NULL)
        return false;										//队空
    x = Q.front->data;										//用x变量返回队头元素
    return true;
}
bool QueueEmpty(LinkQueue Q) {
    return Q.front == NULL;
}
```

##### 双端队列

**双端队列**：只允许从==两端插入、两端删除==的线性表

**输入受限的双端队列**：只允许从==一端插入、两端删除==的线性表

**输出受限的双端队列**：只允许从==两端插入、一端删除==的线性表

#### 栈和队列的应用

##### 括号匹配问题

**思路**：<u>依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检查是否匹配</u>

```c
# define  MaxSize 10
typedef struct {
    char data[MaxSize];
    int top;
} SqStack;

void InitStack(SqStack &S) {
    S.top = -1;											//栈顶指针始终指向栈顶元素
}
bool Push(SqStack &S, char t) {
    if (S.top == MaxSize - 1)
        return false;									//栈满
    S.data[++S.top] = t;
    return true;
}
bool Pop(SqStack &S, char &x) {
    if (S.top == -1)
        return false;									//栈空
    x = S.data[S.top--];
    return true;
}
bool StackEmpty(SqStack S) {
    return S.top==-1;
}
bool bracketCheck(char *str, int length) {
    SqStack S;
    InitStack(S);
    for (int i = 0; i <length ; i++) {
        if (str[i]=='('||str[i]=='['||str[i]=='{'){
            Push(S,str[i]);
        } else{
            //这里是建立在整个字符串都是由扩号组成的基础上进行的
            //也就是如下逻辑不能过滤字符串中的非括号字符
            if (StackEmpty(S))
                return false;						//扫描到右括号且当前栈空，匹配失败
            char topElem;
            Pop(S,topElem);							//栈顶元素出栈
            if (str[i]==')' && topElem!='(')
                return false;
            if(str[i]==']'&&topElem!='[')
                return false;
            if(str[i]=='}'&&topElem!='{')
                return false;
        }
    }
    return StackEmpty(S);					//最后检查栈，若空匹配成功，非空匹配失败
}
```

##### 表达式求值

后缀表达式（逆波兰表达式）、前缀表达式（波兰表达式）

**中缀转后缀**：==左优先==															**中缀转前缀**：==右优先==

`后缀表达式（手算）`

**从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合并为一个操作数**

`后缀表达式（机算）`

1⃣️ 从左往右扫描下一个元素，直到处理完所有元素

2⃣️ 若扫描到操作数则压入栈，并回到1⃣️，否则执行下一步

3⃣️ 若扫描到运算符，则弹出两个栈顶元素（==先弹出的元素是右操作数==），执行相应运算，运算结果压回栈顶，回到1⃣️

`前缀表达式（机算）`

1⃣️ 从右往左扫描下一个元素，直到处理完所有元素

2⃣️ 若扫描到操作数则压入栈，并回到1⃣️，否则执行下一步

3⃣️ 若扫描到运算符，则弹出两个栈顶元素（==先弹出的元素是左操作数==），执行相应运算，运算结果压回栈顶，回到1⃣️

`中缀表达式转后缀（机算）`

1⃣️ 遇到操作数，直接加入后缀表达式

2⃣️ 遇到' ( '，直接入栈；

​	 遇到' ) '，则依次弹出栈内运算符并加入后缀表达式，直到弹出' ( '为止（左括号不加入后缀表达式，因为后缀表达式不使用括号）

3⃣️ 遇到运算符，依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式

​	 若遇到左括号或栈空则停止，之后再把当前运算符入栈

4⃣️ 处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式

$((15\div(7-(1+1)))\times3)-(2+(1+1)) \Rightarrow 15711+-\div3\times211++$

#### 特殊矩阵的压缩存储

##### 数组的存储结构

`一维数组`

==$$LOC(a_i)=LOC(a_0)+i\times L,(0\le i<n)$$==

==$$LOC(a_i)=LOC(a_1)+(i-1)\times L,(1\le i<n)$$==

`二维数组`

(M行N列)

**行优先**：==$$b[i][j]=起始地址+(i*N+j)*sizeof(ElemType)$$==

**列优先**：==$$b[i][j]=起始地址+(j*M+i)*sizeof(ElemType)$$==

##### 矩阵的压缩存储

`对称矩阵`

(按行优先原则将各元素存入一维数组中)

**数组长度**：$$\frac{n(1+n)}{2}$$

**$$a_{i,j}$$对应的数组下标**:

1⃣️ $$i\ge j$$（下三角区和主对角线元素），==$$k=\frac{i(i-1)}{2}+j-1$$==

1⃣️ $$i< j$$（上三角区元素），==$$k=\frac{j(j-1)}{2}+i-1$$==

<img src="数据结构.assets/截屏2022-07-15 17.43.39.png" alt="截屏2022-07-15 17.43.39" style="zoom: 50%;" />

`三角矩阵`

(按行优先原则将各元素存入一维数组中，并==在最后一个位置存储常量c==)

**数组长度**：==$$\frac{n(1+n)}{2}$$==

**$$a_{i,j}$$对应的数组下标**:

1⃣️ $$i\ge j$$（下三角区和主对角线元素），==$$k=\frac{i(i-1)}{2}+j-1$$==

1⃣️ $$i< j$$（上三角区元素），==$$k=\frac{n(n-1)}{2}$$==



<img src="数据结构.assets/截屏2022-07-15 17.59.14.png" alt="截屏2022-07-15 17.59.14" style="zoom:50%;" />

`三对角矩阵`

**特点**：当$|i-j|>1$时，有$a_{i,i}=0$

**数组长度**：==$3n-2$==（每行3个，扣去首尾行各少一个）

**$$a_{i,j}$$对应的数组下标（从0开始）**:==$k=2i+j-3$==

**数组下标k对应的坐标**：==$i=[(k+2)/3]$（[]为取整）,$j=k-2i+3$==

<img src="数据结构.assets/截屏2022-07-26 16.52.11.png" alt="截屏2022-07-26 16.52.11" style="zoom:50%;" />

`稀疏矩阵`

<img src="数据结构.assets/截屏2022-07-26 17.10.57.png" alt="截屏2022-07-26 17.10.57" style="zoom: 67%;" />

### 排序

**稳定性**：关键字相同的元素经过排序后相对顺序是否会改变

#### 插入排序

**定义**：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成

**算法稳定性**：==稳定==

```c
// 直接插入排序
void InsertSort(int A[], int n) {
    int i,j,temp;
    for (i=1; i<n; i++) {
        if (A[i] < A[i-1]) {
            temp = A[i];
            for (j=i-1; j>=0 && A[j]>temp; --j) // j指向i的前一个元素
                A[j+1] = A[j]; 					// 被比较的元素往后挪
            A[j+1] = temp;						// 此处的j+1是为了抵消循环的--j
        }
    }
}
```

```c
// 直接插入排序（带哨兵）
void InsertSort(int A[], int n) {
    int i,j;
    for (i=2; i<=n; i++) {
        if (A[i] < A[i-1]) {
            A[0] = A[i];
            for (j=i-1; A[j]>A[0]; --j) 		// j指向i的前一个元素
                A[j+1] = A[j]; 					// 被比较的元素往后挪
            A[j+1] = A[0];						// 此处的j+1是为了抵消循环的--j
        }
    }
}
```

```c
// 折半插入排序（带哨兵）
void InsertSort(int A[], int n) {
    int i,j,low,high,mid;
    for (i=2; i<=n; i++) {
        A[0] = A[i];
        low = 1; high = i - 1;
        while (low <= high) {
            mid = (low + high) / 2;
            if (A[mid] > A[0])
                high = mid - 1;
            else
                low = mid + 1;
        }
        for (j=i-1; j>=high+1; --j)		// 将[low, i-1]的元素统一后移，故这里high+1是不是也可以写成low呢？
            A[j+1] = A[j];
        A[high+1] = A[0];				// 将哨兵元素插入到low位置
    }
}
```

<img src="数据结构.assets/截屏2022-04-25 21.18.17.png" alt="截屏2022-04-25 21.18.17" style="zoom:50%;" />

#### 冒泡排序

**稳定性**：==稳定==

```c
// 冒泡排序
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
void BubbleSort(int A[], int n) {
    for (int i=0; i<n-1; i++) {					// 即到只遍历到倒二个元素
        bool flag = false;						// 表示本躺冒泡是否发生交换的标志
        for (int j=n-1; j>i; j--) {				// j从最后一个元素开始
            if (A[j-1] > A[j]){					// 只有前面的元素大于后面的元素才发生交换
                swap(A[j-1], A[j]);
                flag = true;
            }
        }
        if (flag = false)
            return;								// 本躺遍历没有发生交换，因为后面的元素比当前元素大
        										// 而前面的元素又比当前小，则说明已经有序
    }
}
```

#### 希尔排序

先将表根据增量d分割成若干个子表，对各个子表分别进行直接插入排序；缩小增量，重复上述过程，直到d=1

```c
// 希尔排序
void ShellSort(int A[], int n) {
    int d, i, j;
    for (d=n/2; d>=1; d=d/2) {				// 每一次循环都划分一次子表
        for (i=d+1; i<=n; ++i) {			// i初始化为每个子表第二个元素的位置
            if (A[i] < A[i-d]) {
                A[0] = A[i]					// A[0]只是暂存单元，不是哨兵
                for (j=i-d; )
            }
        }
    }
}
```





[^1]:即通过首地址和元素序号可在时间O(1)内找到指定的元素
[^2]: 即每个结点只存储数据元素
[^3]: 即带头结点时，不管是否为空链，头指针都指向头结点
