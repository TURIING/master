### 第1章 计算机系统概述

`计算机的分类与发展方向`

**按指令和数据流分类**

1️⃣ **单指令流和单数据流系统**			==冯·诺伊曼体系结构==	2️⃣ **单指令流和多数据流系统**           阵列处理器和向量处理器系统

3️⃣ **多指令流和单数据流系统**          不存在								  4️⃣ **多指令流和多数据流系统**          多处理器和多计算机系统

**计算机系统的组成**

==硬件系统和软件系统==共同构成一个完整的计算机系统

某功能既可以用软件实现也可以用硬件实现，则称==软件硬件在逻辑上是等效的（等价❌）==

**硬件的发展**

1️⃣ 第一代，电子管时代				2️⃣ 第二代，晶体管时代			==开始出现操作系统==

3️⃣ 第三代，中小规模集成电路时代	==开始有了分时操作系统==		4️⃣ 第四代，大规模、超大规模集成电路时代

**早期的冯·诺伊曼机**

冯·诺伊曼在研究EDVAC机时提出了“==存储程序==”的概念；			**基本工作方式**：==控制流驱动方式==

> 存储程序： 指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直到程序执行结束

==冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是指令周期的不同阶段==

**特点**：1⃣️ 计算机硬件系统由==运算器、存储器、控制器、输入设备、输出设备==组成

​				2⃣️ 指令和数据以==同等地位==存储在存储器中，并可按地址寻访			3⃣️ ==指令和数据均用二进制代码表示==

​				4⃣️ 指令由操作码和地址码组成				5⃣️ 指令在存储器内按顺序存放

​				6⃣️  ==以运算器为中心==（**输入、输出设备通过运算器与存储器传送数据**）

**现代计算机结构**

==存储器为中心==、==CPU = 运算器 + 控制器==

`计算机的功能部件`

* **主存储器**

  **组成**：==MAR、MDR、地址译码器==				**工作方式**：==按地址存取方式==（按存储单元的地址进行存取）

  **地址寄存器（MAR）**：==存放访存地址==，经过地址译码后找到所选的存储单元，==MAR位数 = 存储单元的个数==

  **数据寄存器（MDR）**：==用于暂存要从存储器中读或写的信息==，==MDR位数 = 存储字长==

  ​												  ==MDR位数可以不等于数据字长==（当MDR > 数据字长时，数据可以分多次发送）

  ​												  ==现代计算机通常把MAR、MDR集成在CPU中（控制器内）==

  **存储元**：存储二进制的电子元件（电容），每个存储元可存1bit		**存储单元**：每个存储单元存放一串二进制代码

  **存储字**：存储单元中存储的二进制代码						**字长**：计算机每个字包含的位数

  **字**：计算机在进行数据处理，一次存取、加工、传送的数据长度，一个字由多个字节组成；

  ​		  ==随架构改变字长==（如64位CPU中一字为64位）

* **运算器**

	**功能**：==用于算术运算（加减乘除）和逻辑运算（与或非）==

	**组成**：1️⃣ **算术逻辑单元（ALU）**，通过内部复杂的电路实现算术运算、逻辑运算

	​				2️⃣ **累加器（ACC）**，用于存放操作数或运算结果	3️⃣ **乘商寄存器（MQ）**，在乘除运算时用于存放操作数或运算结果

	​				4️⃣ **操作数寄存器（X）**，用于存放操作数		5️⃣ **变址寄存器（IX）**				6️⃣ **基址寄存器（BR）**

	​				7️⃣ **程序状态寄存器（PSW、标志寄存器）**

	​						用于存放ALU运算得到的一些标志信息或处理机的状态信息（如结果是否溢出、有无进位或错位、结果是否为负）
	
	​				8️⃣ **暂存寄存器**		9️⃣ **移位器**		🔟 **计数器**


* **控制器**

	1⃣️ **控制单元（CU）**， 分析指令，给出控制信号    2⃣️ **程序计数器（PC）**，用于==存放下一条指令的地址==，==有自动加1功能==

	3⃣️ **指令寄存器（IR）**，==存放当前执行的指令==

==运算器和控制器都含有寄存器；寄存器的基本单元是D触发器==

|  是否可见  |                 器件                 |
| :--------: | :----------------------------------: |
|  用户可见  |  ==通用寄存器、程序状态寄存器、PC==  |
| 用户不可见 | ==MAR、MDR、指令寄存器、暂存寄存器== |

`计算机软件的分类`

* **系统软件**

  ==操作系统、数据库管理系统（DBMS）、语言处理程序（编译器）、分布式软件系统==

  ==网络软件系统、标准库程序、服务性程序（链接器、代码调试器）==

  > 数据库管理系统（DBMS）： 位于用户和操作系统之间的一层数据管理软件，是==系统软件==
  >
  > 数据库系统（DBS）： 指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成，是==应用软件==

* **应用软件**

`计算机系统的多级层次结构`

<img src="组成原理.assets/截屏2022-04-19 00.31.31.png" alt="截屏2022-04-19 00.31.31" style="zoom: 50%;" />

==下层是上层的基础，上层是下层的扩展==；==上下层是可以分割的，仅有下层而没有上层也是可以的==；==上层是下层的功能实现==

`编译程序和解释程序`

==编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序==

==解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句==

`计算机的性能指标`

* **机器字长**

  （指计算机==进行一个整数运算所能处理的二进制数据的位数==，衡量计算机并行处理的能力）

  ==机器字长等于CPU内部用于整数运算的运算器位数和通用寄存器位数（浮点寄存器位数❌）==

  **指令字长**：一个指令中包含的二进制代码的位数				**存储字长**：一个存储单元存储二进制数据的位数

  **数据字长**：数据总线一次能并行传送信息的位数

  ==机器字长、指令字长、存储字长在数值上可能不相等==

* **数据通路带宽**

	（<u>指数据总线一次所能并行传送信息的位数</u>，衡量计算机在功能级部件间传送数据的能力）

	**数据通路**：数据在功能部件之间传送的路径（如内存到CPU）

* **吞吐量**

  （指系统在单位时间内处理请求的数量）

  ==从用户观点看，评价计算机系统性能的综合参数是吞吐率==

* **响应时间**

	（指用户向计算机发送一个请求，到系统对该请求作出响应并获得所需结果的等待时间）

* **主频和CPU时钟周期**

  **CPU时钟周期**：又称<u>节拍、T周期</u>；==CPU中最小的时间单位==(us、ns)，执行指令的每个动作至少需要1个时钟周期，

  ​								==$CPU时钟周期 = \frac{1}{主频}$==

  **主频（CPU时钟频率）**：主频越高，执行指令的速度越快（Hz）

* **CPI**

	（执行一条指令所需的时钟周期数）

	对于一个程序或一台机器来说，CPI指该程序或该机器指令集中的所有指令执行所需的**平均时钟周期数**

	==执行一条指令的耗时 = CPI x CPU时钟周期==；==时钟频率并不会影响CPI，但可加快指令的执行速度==

	>**主频高的CPU不一定比主频低的CPU快**
	>
	>如A的主频2GHz，CPI=10；B的主频1GHz，CPI=1
	>
	>**若CPI相同，主频高的CPU也不一定比主频低的CPU快**
	>
	>还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法，而B支持乘法

* **CPU执行时间**

	（运行一个程序所花费的时间）

	==$CPU执行时间 = \frac{CPU时钟周期数}{主频} = \frac{指令条数\times CPI}{主频} = CPI \times 指令条数 \times 时钟周期$==

* **IPS**

	（每秒执行多少条指令）==$IPS = \frac{主频}{CPI}$==

	**MIPS**:==每秒执行多少百万条指令==，==$MIPS = \frac{指令条数}{执行时间\times 10^6} = \frac{主频}{CPI\times 10^6}$==

* **FLOPS**

	（每秒执行多少次浮点运算）==$MFLOPS = \frac{浮点操作次数}{执行时间\times 10^6}$==

	==用于评估科学计算的计算机浮点运算性能==
	
	**$$K(10^3)、M（10^6）、G(10^9)、T(10^{12})$$**

<u>当前设计高性能计算机的重要技术途径是采用并行处理技术</u>

**专业术语**

>**基准程序**
>
><u>用来进行性能评价的一组程序</u>（鲁大师）
>
>**系列机**： 具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
>
>**兼容**：指计算机==软件或硬件==的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统（在==同一系列不同型号==的计算机间通用）
>
>**单片机**：<u>CPU + 存储器 + 中断、IO = 单片机</u>

### 第2章 数据的表示和运算

`进制的相互转换`

* **二进制 <—> 八进制、十六进制**

	$二进制\to 八进制：1111000010.01101\Rightarrow 001\ 111\ 000\ 010.011\ 010\Rightarrow 1702.32$（3位一组，每组转换成八进制符号）

	$二进制\to 十六进制：1111000010.01101\Rightarrow 0011\ 1100\ 0010.0110\ 1000\Rightarrow 3c2.68$（4位一组，每组转换成十六进制符号）

	$八进制\to 二进制：(251.5)_8\Rightarrow 010\ 101\ 001.101$（每位八进制对应成3位二进制）

	$十六进制\to 二进制：(AE86.1)_{16}\Rightarrow 1010\ 1110\ 0110.0001$（每位十六进制对应成4位二进制）

* **任意进制 —> 十进制**

	$二进制：10010010.110\Rightarrow 1\times 2^7+1\times 2^4+1\times 2^1+1\times 2^{-1}+1\times 2^{-2}=146.75$

	$八进制：251.5\Rightarrow 2\times 8^2+5\times 8^1+1\times 8^0+5\times 8^{-1}= 168.625$

	$十六进制：AE86.1\Rightarrow 10\times 16^3 + 14\times 16^2+8\times 16^1+6\times 16^0+1\times 16^{-1} = 44678.0625$

* **十进制 -> 任意进制**

	$十进制\to 二进制：75\Rightarrow 1001011；0.3\Rightarrow 0.01..B$

	<center class="half">
	    <img src="组成原理.assets/截屏2022-09-28 09.03.02.png" alt="截屏2022-09-28 09.03.02" style="zoom:40%;" />
	    <img src="组成原理.assets/截屏2022-09-28 09.10.09.png" alt="截屏2022-09-28 09.10.09" style="zoom:40%;margin-left:100px" />
	</center>

`BCD码`

* **8421码**（8、4、2、1分别对应每一位的权值）

	$十进制\to 二进制：985\Rightarrow 1001\ 1000\ 0101$

	$加法：5+8=13\Rightarrow 0101+1000=1101+0110=1\ 0011=0001\ 0011$（若加法结果为10～15，则+6（0110）修正）

	<img src="组成原理.assets/截屏2022-09-28 09.38.58.png" alt="截屏2022-09-28 09.38.58" style="zoom:33%;" />

* **余3码**（8421码 + 0011）

	<img src="组成原理.assets/截屏2022-09-28 09.39.45.png" alt="截屏2022-09-28 09.39.45" style="zoom:33%;" />

* **2421码**（改变权值定义；2、4、2、1分别对应每一位的权值）

	<img src="组成原理.assets/截屏2022-09-28 09.43.33.png" alt="截屏2022-09-28 09.43.33" style="zoom:33%;" />

	==表示0～4时，最高位为0；表示5～9时，最高位为1==

`无符号整数`

==$n\ bit无符号整数表示范围0～2^n-1，超出则溢出$==

**加法**：从最低位开始，按位相加，并往更高位进位

**减法**： 1⃣️ ==被减数”不变，“减数” 全部位按位取反、末位+1，减法变加法==

​				2⃣️ <u>从最低位开始，按位相加，并往更高位进位</u>

<img src="组成原理.assets/截屏2022-09-28 09.57.06.png" alt="截屏2022-09-28 09.57.06" style="zoom:28%;" />

#### 定点数的表示与运算

##### 定点数的表示

`无符号数`

(全部二进制位均为数值位)

**范围**:==$$0～2^n-1$$==

==通常只有无符号整数，没有无符号小数==

`补码`

定点整数：==$$[x]_补 = 1,00..00\Rightarrow x=-2^n$$==

定点小数：==$$[x]_补 = 1.00..00 \Rightarrow x=-1$$==

==$$[x]_补 \to [-x]_补$$：符号位、数值位全部取反，末位加1==

`移码`

**常用于表示浮点数的阶码** ==只能表示整数==

==补码的符号位取反即移码==

`与原码的相互转换`

|      |   正数   |                     负数                      |
| :--: | :------: | :-------------------------------------------: |
| 反码 | ==相同== | ==若符号位为1，则符号位不变，数值位全部取反== |
| 补码 | ==相同== |    ==符号位不变，数值位按位取反，末位加1==    |

（字长为n+1）

|      |           整数范围            |               小数范围                |                      真值0                      |
| :--: | :---------------------------: | :-----------------------------------: | :---------------------------------------------: |
| 原码 | ==$$-(2^n-1)\le x\le2^n-1$$== | ==$$-(1-2^{-n})\le x \le 1-2^{-n}$$== | ==不唯一，$$[+0]_原 = 00000,[-0]_原 = 10000$$== |
| 反码 |            同原码             |                同原码                 |  ==不唯一$$[+0]_反 = 00000,[-0]_反 = 11111$$==  |
| 补码 |  ==$$-2^n\le x \le 2^n-1$$==  |     ==$$-1\le x \le 1-2^{-n}$$==      |      ==唯一，$$[+0]_补 =[-0]_补 00000$$==       |
| 移码 |            同补码             |                  无                   |     ==唯一，$$[+0]_移 = [-0]_移 = 10000$$==     |

### 第3章 存储系统

$K:2^{10}、M:2^{20}、G:2^{30}、T:2^{40}$；$1ms=1\times 10^{-3}s、1us=1\times 10^{-6}s；1ns=1\times 10^{-9}s$

`存储器的层次化结构`

**主存—辅存**：==解决了主存容量不够的问题==						**Cache—主存**：==解决了主存和CPU速度不匹配的问题==

主存和Cache之间的数据调动是由==硬件==自动完成的，对==所有程序员是透明的==

主存和辅存之间的数据调动是由==硬件和操作系统==共同完成的，对==应用程序员是透明的==

计算机的存储器采用分级方式是**为了解决容量、速度、价格三者之间的矛盾**

==计算机的存储系统包括CPU内部寄存器、Cache、主存和外存==

`存储器的分类`

**按存储介质分类**

<u>磁表面存储器</u>（磁盘、磁带）、<u>半导体存储器</u>（主存、Cache）、<u>光存储器</u>（光盘）

**按存取方式分类**

* **随机存储器（RAM）**

	存取时间与存储单元的物理位置==无关==

* **只读存储器（ROM）**

	存储器的内容只能随机读出而不能写入		==ROM和RAM均为随机存取且均是半导体存储器==

* **串行访问存储器**

	（读写某个存储单元所需时间与存储单元的物理位置有关）

	* **顺序存取存储器（SAM）**

		读写一个存储单元所需时间==取决于存储单元所在的物理位置==（磁带）；==存取速度慢==

	* **直接存取存储器（DAM）**

		先<u>直接选取信息所在区域，然后按顺序方式存取</u>（磁盘、光盘）；==既有随机存取特性，也有顺序存取特性==

* **相联存储器**

	可以按==内容或地址==检索到存储位置进行读写（快表）

| 顺序访问 | 既可顺序访问又可随机访问 |
| :------: | :----------------------: |
|   磁带   |     光盘、U盘、磁盘      |

**按信息的可保存性**

* **易失性存储器**				 断电后，存储信息即**消失**（RAM）

* **非易失性存储器**			断电后，存储信息**依然保持**（ROM）
* **破坏性读出**				     信息读出后，原存储信息**被破坏**
* **非破坏性读出**              信息读出后，原存储信息**不被破坏**

`存储器的性能指标`

**存储容量**

==存储容量 = 存储字数 X 字长==（如8Kx8位，即$2^{13}\times 8bit$）

**单位成本**

==$每位价格 = \frac{总成本}{总容量}$==

**存储速度**

==$数据传输率（主存带宽） = \frac{数据的宽度（存储字长）}{存储周期}$==

**存取时间**：指从启动一次存储器操作到完成该操作所经历的时间

**存取周期**：连续两次独立访问存储器操作之间所需的最小时间间隔

<img src="组成原理.assets/截屏2022-06-28 21.16.34.png" alt="截屏2022-06-28 21.16.34" style="zoom: 60%;" />

`主存储器的基本组成`

<img src="组成原理.assets/截屏2022-08-18 17.44.29.png" alt="截屏2022-08-18 17.44.29" style="zoom:60%;" />

**主存储器的基本构成**

<img src="组成原理.assets/截屏2022-08-18 18.01.32.png" alt="截屏2022-08-18 18.01.32" style="zoom:60%;" />

`半导体随机存储器`

==SRAM、DRAM都属于易失性存储器==

 **DRAM**

==用于主存==（**现在的主存通常采用SDRAM**，SDRAM也需要周期性刷新）

存储元使用==栅极电容==存储信息，==破坏性读出==，读出后需要重写信息

==分两次送行列地址==（地址线复用技术，**导致地址线、地址引脚减半**）

**优点**：==容易集成、成本低、集成度高、功耗低==					**缺点**：==存取速度比SRAM慢==（由于读出后需要重写）

**芯片引脚数**：（1024x8位）

==$数据线=数据位数=8；行列选通线：2（片选线用行列选通线代替）；读/写控制线：1或2$==

==$地址线=[log_2(寻址范围)]/2=[log_2(1024)]/2=5；$==

**刷新**：（**刷新周期为2ms，每次刷新一行存储单元**（==刷新以行为单位==））

<u>“刷新”由存储器独立完成，不需要CPU控制</u>；<u>采用行列地址是为了减少选通线的数量</u>

==一次完整的刷新过程占用一个存储周期==

* **集中刷新**

	在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作（称为<u>死时间、访存死区</u>）

* **分散刷新**

  把对每行的刷新分散到各个工作周期中，一个存储器的系统工作周期分为两部分，前半部分用于正常读写，后半部分用于刷新

  ==不存在死时间==

* **异步刷新**

  将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求

  **既可缩短“死时间”，又能充分利用最大刷新间隔为2ms的特点**

**SRAM**

==用于Cache==、存储元使用==双稳态触发器==存储信息，==非破坏性读出==，==同时送行列地址==

**优点**：==存取速度快==												**缺点**：==成本高、集成度低、功耗大==

**芯片引脚数**：（1024x8位）

==$数据线=数据位数=8；片选线：1；读/写控制线：1或2$==

==$地址线=log_2(寻址范围)=log_2(1024)=10；(32K\times 16\Rightarrow 地址线=15)$==

`主存储器与CPU的连接`

**位扩展**

<img src="组成原理.assets/截屏2022-08-18 18.05.35.png" alt="截屏2022-08-18 18.05.35" style="zoom:50%;" />

**字扩展**

* **线选法**

	==$n条线\to n个选片信号$==、电路简单、==地址空间不连续==（有的地址不能使用）

	<img src="组成原理.assets/截屏2022-08-18 18.17.39.png" alt="截屏2022-08-18 18.17.39" style="zoom:50%;" />



* **译码片选法**

	==$n条线\to 2^n个选片信号$==、电路复杂、==地址空间连续==

	<img src="组成原理.assets/截屏2022-08-18 18.14.34.png" alt="截屏2022-08-18 18.14.34" style="zoom:50%;" />

**字位同时扩展**

<img src="组成原理.assets/截屏2022-08-18 18.24.56.png" alt="截屏2022-08-18 18.24.56" style="zoom:50%;" />

**译码器**

<img src="组成原理.assets/截屏2022-08-18 18.27.46.png" alt="截屏2022-08-18 18.27.46" style="zoom:50%;" />

`双端口RAM和多模块存储器`

**双端口RAM**

**双端口存储器具有两套独立读/写口，具有各自的地址寄存器和译码电路**

1⃣️ 两个端口同时对不同地址单元存取数据 🉑️			2⃣️ 两个端口同时对同一地址单元读出数据 🉑️

3⃣️ 两个端口同时对同一地址单元写入数据 （❌写入错误）

4⃣️ 两个端口同时对同一地址单元，一个写入数据，另一个读出数据（❌读出错误）

**解决**：置“忙”信号为0，由判断逻辑决定暂时关闭一个端口，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间短				后再访问

**多体并行存储器**

<u>每个模块都有相同的容量和存取速度</u>

<u>各模块都有独立的读写控制电路、地址寄存器和数据寄存器，它们既能并行又能交叉工作</u>

* **高位交叉编址**

  ==不满足程序局部性原理==

  <img src="组成原理.assets/截屏2022-08-18 21.44.07.png" alt="截屏2022-08-18 21.44.07" style="zoom:50%;" />

* **低位交叉编址**

  ==$连续取n个存储字耗时T+(n-1)r$==（每个存储体存取周期为T，存取时间为r）

  ==$为了使流水线不间断，应保证m\ge \frac{T}{r}$==（m体交叉存储器，每个存储体存取周期为T，<u>存取时间/总线传输周期</u>为r）

  ==满足程序局部性原理==

  <img src="组成原理.assets/截屏2022-08-18 21.44.30.png" alt="截屏2022-08-18 21.44.30" style="zoom:50%;" />
  
  （$蓝色位数为log_2N$，N为芯片数）

**单体多字存储器**

（类似于字扩展法）

==每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字==（不能单独取其中某个字）

`只读存储器`

==CD-ROM是只读型光盘存储器（顺序存取），不属于只读存储器==

**掩模式只读存储器**（MROM）

厂家在生产过程直接写入，==写入以后任何人无法改变内容==

**优点**：==可靠性高，集成度高，价格便宜==				**缺点**：==灵活性差==

**一次可编程只读存储器**（PROM）

允许用户利用专门的设备写入自己的程序，==一旦写入，内容无法改变==

**可擦除可编程只读存储器**（EPROM）

允许用户写入信息，且==可多次重写==；==随机存取==

* **紫外线擦除**（UVEPROM）            需要擦除全部，然后写入

* **电擦除**（EEPROM）                      只需擦除特定的字

**闪速存储器（Flash Memory）**

（U盘、SD卡）<u>存储元由mos管组成</u>

==断电后也能保存信息，且可进行多次快速擦除重写==（读比写快，因为写入需要先擦除原有数据）

**固态硬盘**

<u>由控制单元和存储单元（Flash芯片）构成</u>			==速度快、功耗低，但价格高==

<img src="组成原理.assets/截屏2022-08-19 16.42.23.png" alt="截屏2022-08-19 16.42.23" style="zoom: 55%;" />

==静态磨损均衡算法比动态磨损均衡算法的表现更优秀==（因为在没有写入数据的时候进行的数据迁移）

`磁盘存储器`

**磁表面存储器**

<u>每次读写只能1bit</u>

**优点**： 1⃣️ ==存储容量大，位价格低== 								   2⃣️ 记录介质可以重复使用

​				 3⃣️ 记录的信息可以长期保存而不丢失	  		 4⃣️ **非破坏性读出**，读出时不需要再生

**缺点**： 1⃣️ ==存取速度慢==		2⃣️ 机械结构复杂		3⃣️ 对工作环境要求较高（容易被磁场干扰）

**磁盘设备的组成**

* **存储区域**

​			一块硬盘有若干个记录面，每个记录面划分为若干条磁道，每条磁道又划分为若干个扇区

​			==扇区（块）是磁盘读写的最小单位（磁盘按块存取）==

​			**磁头数**：即记录面数（一个记录面对应一个磁头），表示硬盘共有多少个磁头

​			**柱面数**：表示硬盘每一面盘片上有多少条磁道

​			**扇区数**：表示每一条磁道上有多少个扇区；==每一个扇区所能存储的二进制数据大小都是相同的==

* **硬盘存储器**

	 1⃣️ **磁盘驱动器**，核心部件是磁头组件和盘片组件

	 2⃣️ **磁盘控制器**，是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA

**磁盘的性能指标**

* **磁盘容量**

	（一个磁盘所能存储的字节总数）

	1⃣️ **非格式化容量**，指磁记录表面可以利用的磁化单元总数

	2⃣️ **格式化容量**，指按照某种特定的记录格式所能存储信息的总量；一般<u>非格式化容量 > 格式化容量</u>

* **记录密度**

	1⃣️ **道密度**，沿磁盘半径方向单位长度上的磁道数（如60道/cm）

	2⃣️ **位密度**，磁道单位长度上所能记录的二进制代码位数（如600bit/cm）

	​       ==每个磁道的位密度都不同，越内侧的磁道位密度越大==（由于**所有磁道记录的信息量是相等的**，但磁道半径不一样）

	3⃣️ **面密度**，道密度与位密度的乘积

* **平均存取时间**

	==$平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）$==

* **数据传输率**

	（磁盘存储器在单位时间内向主机传送数据的字节数）

	==$数据传输率=rN$==（磁盘转速为r（转/秒），每条磁道容量为N个字节）

**磁盘地址**

<img src="组成原理.assets/截屏2022-08-19 16.18.13.png" alt="截屏2022-08-19 16.18.13" style="zoom:50%;" />

**硬盘的工作过程**

硬盘的主要操作是寻址、读盘、写盘；每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字；硬盘属于机械式部件，其==读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据==

**磁盘阵列**

廉价冗余磁盘阵列（RAID），是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性（**编号中的数值越大可靠性越高**）和安全性

1⃣️ **RAID0**：无冗余和无校验的磁盘阵列（==没有容错能力==；类似低位交叉编址的多体存储器）

<img src="组成原理.assets/截屏2022-08-19 16.33.08.png" alt="截屏2022-08-19 16.33.08" style="zoom:45%;" />

2⃣️ **RAID1**：镜像磁盘阵列（存两份数据，==意味着容量减少一半==）

<img src="组成原理.assets/截屏2022-08-19 16.34.04.png" alt="截屏2022-08-19 16.34.04" style="zoom:45%;" />

3⃣️ **RAID2**：采用纠错的海明码的磁盘阵列

（逻辑上连续的几个bit物理上分散存储在各个盘中，4bit信息位+3bit海明校验位，可纠正一位错）

<img src="组成原理.assets/截屏2022-08-19 16.30.57.png" alt="截屏2022-08-19 16.30.57" style="zoom:40%;" />

4⃣️ **RAID3**：位交叉奇偶校验的磁盘阵列

5⃣️ **RAID4**：块交叉奇偶校验的磁盘阵列

6⃣️ **RAID5**：无独立校验的奇偶校验磁盘阵列

`Cache的概念和原理`

**“Cache—主存”系统的平均访问时间**：

<u>不同时访问</u>：==$t=Ht_c+(1-H)(t_c+t_m)$==（$H为命中率，t_c为访问一次Cache所需时间，t_m为访问一次主存所需时间$）

<u>同时访问</u>：==$t=Ht_c+(1-H)t_m$==

==主存与Cache之间以块为单位进行数据交换==

`Cache和主存的映射方式`

* **全相联映射**

  **访存过程**：（CPU访问主存地址1...1101001110）

  1⃣️ 对比Cache中所有块的标记和主存地址的前22位  2⃣️ 若标记匹配且有效位 = 1，则命中 ,访问块内地址为001110的单元

  3⃣️ 若未命中或有效位 = 0， 则正常访问主存

  <img src="组成原理.assets/截屏2022-08-19 17.15.04.png" alt="截屏2022-08-19 17.15.04" style="zoom:45%;" />

  **优点**：<u>Cache存储空间利用充分，命中率高</u>

  **缺点**：<u>查找标记最慢</u>

  **替换算法**：<u>Cache完全满了才需要替换</u>，需要在<u>全局</u>选择替换哪一块

* **直接映射**

  ==$主存块在Cache中的位置=主存块号\%Cache总块数$==

  ==$若Cache总块数=2^n，则主存块号末尾n位直接反映它在Cache中的位置（由于主存块号\%2^n相当于留下最后n位二进制数）$==

  ==因此只需主存块号的其余位作为标记即可==

  <img src="组成原理.assets/截屏2022-08-19 17.54.45.png" alt="截屏2022-08-19 17.54.45" style="zoom:45%;" />

  **访存过程**：（CPU访问主存地址01000001110 ）

  1⃣️ 根据主存块号的后3位确定Cache行

  2⃣️ 若主存块号的前19位与Cache标记匹配且有效位 = 1，则命中，访问块内地址为001110的单元

  3⃣️ 若未命中或有效位 = 0，则正常访问主存

  **优点**：<u>查找标记速度最快</u>

  **缺点**：<u>灵活性差、Cache存储空间利用不充分，命中率低</u>

  **替换算法**：<u>不需要替换算法</u>，如果对应位置非空，则毫无选择地直接替换

* **组相联映射**

	==$所属分组=主存块号\%分组数$==

	==$若Cache总组数=2^n，则主存块号末尾n位直接反映它在Cache中的组号，因此只需主存块号的其余位作为标记即可$==

	<img src="组成原理.assets/截屏2022-08-19 17.56.47.png" alt="截屏2022-08-19 17.56.47" style="zoom:45%;" />

	**访存过程**：（CPU访问主存地址1...1101001110）

	1⃣️ 根据主存块号的后2位确定所属分组号

	2⃣️ 若主存块号的前20位与分组内的某个标记匹配且有效位 = 1，则Cache命中，访问块内地址为001110的单元
	3⃣️ 若未命中或有效位 = 0，则正常访问主存

	<img src="组成原理.assets/截屏2022-08-19 18.02.18.png" alt="截屏2022-08-19 18.02.18" style="zoom:45%;" />

	**优点**：<u>另外两种方法的折中，综合效果较好</u>
	
	**替换算法**：<u>分组内满了才需要替换</u>，需要在<u>分组内</u>选择替换哪一块

`Cache替换算法`

* **随机算法**（RAND）

	（若Cache已满，则随机选择一块替换）

	==实现简单、命中率低（没考虑到局部性原理）==

* **先进先出算法**（FIFO）

	（若Cache已满，则替换最先被调入的Cache块）

	==实现简单、没考虑到局部性原理==、==会出现抖动现象==（刚被替换的块很快又被调入）

* **近期最少使用算法**（LRU）

	（为每一个Cache块设置一个计数器，用于记录每个Cache块已经多久没被访问了，当Cache满后替换计数器最大的）

	1⃣️ 未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1

	2⃣️ 命中时，所命中的行的计数器清零，比其低的计数器加1,其余不变

	3⃣️ 未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1

	==$若Cache块的总数为2^n，则计数器只需n位$==、==Cache装满后所有计数器的值一定不重复==

	<img src="组成原理.assets/截屏2022-08-20 14.52.20.png" alt="截屏2022-08-20 14.52.20" style="zoom:50%;" />

	==基于局部性原理、命中率高==、==若被频繁访问的主存块数量 > Cache行的数量，则可能发生抖动==

* **最不经常使用算法**（LFU）

	（为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后替换计数器最小的）

	新调入的块的计数器为0，之后每被访问一次计数器+1；需要替换时，选择计数器最小的一行

	（若有多个计数器最小的行，可按行号递增或FIFO策略进行选择）

	==不遵循局部性原理==（曾经被经常访问的主存块在未来不一定会用到）、==实际运行效果不如LRU==

`Cache写策略`

* **写命中**

	* **写回法**

		（当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块**被换出时**才写回主存）

		需要增加一位==脏位==表示是否被修改过

	* **全写法**（写直通法）

		（当CPU对Cache写命中时，必须把数据**同时写入**Cache和主存，一般使用写缓冲）

* **写不命中**

	* **写分配法**

		（当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改；通常**搭配写回法**使用）

	* **非写分配法**

		（当CPU对Cache写不命中时，**只写入主存，不调入Cache**；**搭配全写法使用**）

`多级Cache`

<u>离CPU越近，速度越快，容量越小；离CPU越远，速度越慢，容量越大</u>

==各级Cache之间采用全写法+非写分配法；Cache—主存之间采用写回法+写分配法==

### 第5章 中央处理器

`CPU的功能和基本结构`

**CPU的功能**

1️⃣ **指令控制**，完成取指令、分析指令和执行指令的操作，即程序的顺序控制

2️⃣ **操作控制**，一条指令的功能往往是由若干操作信号的组合来实现的；CPU管理并产生由内存取出的每条指令的操作信号，

​		把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作

3️⃣ **时间控制**，对各种操作加以时间上的控制；时间控制要为每条指令按时间顺序提供应有的控制信号

4️⃣ **数据加工**，对数据进行算术和逻辑运算

5️⃣ **中断处理**，对计算机运行过程中出现的异常情况和特殊请求进行处理

**CPU的基本机构**

* **运算器**

	**组成**：1️⃣ **算术逻辑单元**（ALU）：主要功能是进行算术/逻辑运算

	​				2️⃣ **通用寄存器组**：如AX、BX、 CX、DX、SP，用于存放操作数和各种地址信息

	​				3️⃣ **暂存寄存器**：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容

	​					（配合CPU内部单总线方式）

	​				4️⃣ **累加寄存器**（ACC）：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算

	​				5️⃣ **程序状态字寄存器**：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，

	​						PSW中的这些位参与并决定微操作的形成

	​				6️⃣ **移位器**：对运算结果进行移位运算				7️⃣ **计数器**（CT）：控制乘除运算的操作步数

* **控制器**

	（协调并控制计算机各部件执行程序的指令序列，**基本功能包括取指令、分析指令、执行指令**）

	**取指令**：自动形成指令地址；自动发出取指令的命令

	**分析指令**：操作码译码（分析本条指令要完成什么操作）；产生操作数的有效地址

	**执行指令**：根据分析指令得到的操作命令和操作数地址形成操作信号控制序列，控制运算器、存储器及I/O设备完成相应的操作

	**组成**：1️⃣ **程序计数器**（PC）：用于指出下一条指令在主存中的存放地址

	​				2️⃣ **指令寄存器**（IR）：用于保存当前正在执行的那条指令

	​				3️⃣ **指令译码器**：仅对操作码字段进行译码，向控制器提供特定的操作信号

	​				4️⃣ **微操作信号发生器**：根据IR的内容、PSW的内容及时序信号，产生控制整个计算机系统所需的

	​						各种控制信号，其结构有组合逻辑型和存储逻辑型两种

	​				5️⃣ **时序系统**：用于产生各种时序信号，它们都是由统一时钟(CLOCK) 分频得到

	​				6️⃣ **存储器地址寄存器**（MAR）：用于存放所要访问的主存单元的地址

	​				7️⃣ **存储器数据寄存器**（MDR）：用于存放向主存写入的信息或从主存中读出的信息

`指令周期`

**指令周期**：CPU从内存<u>取出一条指令并执行这条指令</u>的时间总和，==通常用若干机器周期来表示==

**中断周期**：执行一次中断所需要的周期

**CPU周期**：又称<u>机器周期</u>，从内存取一条指令的最短时间，==包含若干个时钟周期==

==不同指令的指令周期可能不同，每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等==

<center class="half">
<img src="组成原理.assets/截屏2022-09-03 14.45.52.png" alt="截屏2022-09-03 14.45.52" style="zoom:65%;" />
    <img src="组成原理.assets/截屏2022-09-04 16.40.28.png" alt="截屏2022-09-04 16.40.28" style="zoom:55%;margin-left:50px" />
</center>



==对于间接寻址的指令，需要包括间址周期==（取操作数需要先访问一次主存取出有效地址，然后访问主存，取操作数）

==四个工作周期都有CPU访存操作==，只是访存的目的不同：

**取指周期**是为了<u>取指令</u>；**间址周期**是为了<u>取有效地址</u>；**执行周期**是为了<u>取操作数</u>；**中断周期**是为了<u>保存程序断点</u>

==为了区别不同的工作周期，在CPU内分别设置了4个标志触发器==FE、IND、EX、INT，状态为1表示有效



**数据流向**

* **取指周期**

	1️⃣ 当前指令地址送至存储器地址寄存器，(PC) —> MAR

	2️⃣ CU发出控制信号，经控制总线传到主存，这里是读信号，1—> R

	3️⃣ 将MAR所指主存中的内容经数据总线送入MDR，M(MAR) —> MDR

	4️⃣ 将MDR中的内容送入IR，(MDR)> IR         5️⃣ CU发出控制信号，形成下一条指令地址，(PC) + 1 →PC

* **间址周期**

	1️⃣ 将指令的地址码送入MAR，Ad(IR) —> MAR 或 Ad(MDR) —> MAR

	2️⃣ CU发出控制信号，启动主存做读操作，1—> R

	3️⃣ 将MAR所指主存中的内容经数据总线送入MDR，M(MAR) —> MDR

	​		或将有效地址送至指令的地址码字段（替换掉原指令的地址码）， (MDR)→ Ad(IR)

* **执行周期**

	不同指令的执行周期操作不同，没有统一的数据流向

* **中断周期**

	1️⃣ CU控制将SP减1，修改后的地址送入MAR，(SP) - 1→SP，(SP) —> MAR

	​		（减1是因为内存中的堆栈是反过来的，高地址在上，低地址在下）

	​		本质上是将断点存入某个存储单元，假设其地址为a，故a —> MAR

	2️⃣ CU发出控制信号，启动主存做写操作，1—>W           3️⃣ 将断点(PC内容)送入MDR， (PC) —> MDR

	4️⃣ CU控制将中断服务程序的入口地址(由向量地址形成部件产生)送入PC，向量地址 —> PC

**指令执行方案**

* **单指令周期**

	（对所有指令都选用<u>相同的执行时间</u>来完成）

	指令之间==串行==执行（即下一条指令只能在前一条指令执行结束后才能启动）

	==指令周期取决于执行时间最长的指令的执行时间==

	**缺点**：==会降低整个系统的运行速度==（对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成）

* **多指令周期**

	（对不同类型的指令选用不同的执行步骤来完成）
	指令之间==串行==执行；可选用不同个数的时钟周期来完成不同指令的执行过程，<u>指令需要几个周期就分配几个</u>

	**缺点**：需要更复杂的硬件设计

* **流水线方案**

	（在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中）

	指令之间==并行==执行

`数据通路`

**数据通路的基本结构**

* **专用数据通路方式**

  （根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，即每个寄存器有多条线连接目标器件）

  **优点**：==性能较高，基本不存在数据冲突现象==				**缺点**：==结构复杂，硬件量大， 不易实现==

  > 如果直接用导线连接，相当于多个寄存器同时并且一直向ALU传输数据
  >
  > **解决方法1**：使用多路选择器，根据控制信号选择一路输出
  >
  > **解决方法2**：使用三态门可以控制每一路是否输出
  >
  > ​							（如R0out为1时 R中的数据输出到A端；R0out为0时，R中的数据无法输出到A端）

  <img src="组成原理.assets/截屏2022-09-03 14.04.17.png" alt="截屏2022-09-03 14.04.17" style="zoom:50%;" />

  **取指过程**：

  <img src="组成原理.assets/截屏2022-09-08 16.57.53.png" alt="截屏2022-09-08 16.57.53" style="zoom:50%;" />

* **CPU内部单总线方式**

	（将所有寄存器的输入端和输出端都连接到一条公共的通路上）

	**优点**：==结构简单，容易实现==					**缺点**：==数据传输存在较多冲突的现象，性能较低==

	* **寄存器之间的数据传送**
	
		（把PC内容送至MAR）
	
		 (PC) —> Bus —> MAR            PCout有效，PC内容送总线；MARin有效，总线内容送MAR
	
	* **主存与CPU之间的数据传送**
	
		（CPU从主存读取指令）
	
		 (PC) —> Bus —>MAR             PCout和MARin有效，下一条指令地址 —> MAR
	
		 1 —> R                                   CU发读命令（通过控制总线发出）
	
		 MEM(MAR) —> MDR              MDRin有效
	
		 MDR —> Bus —> IR                 MDRout和IRin有效，下一条指令 —> IR
	
	* **执行算术或逻辑运算**
	
		（一条加法指令）
	
		 Ad(IR) —> Bus —> MAR                      MDRout和MARin有效
	
		 1 —> R                                                 CU发读命令
	
		 MEM(MAR) —> 数据线 —> MDR         MDRin有效
	
		 MDR —> Bus —> Y                               MDRout和Yin有效，操作数 —> Y，Y为暂存寄存器
	
		 (ACC)+(Y) —> Z                                     ACCout和ALUin有效，CU向ALU发送加命令，ACC存放指令携带的另一操作数
	
		 Z —> ACC                                              Zout和ACCin有效，结果 —> ACC 
	
	<img src="组成原理.assets/截屏2022-09-03 14.13.45.png" alt="截屏2022-09-03 14.13.45" style="zoom:50%;" />
	

`硬布线控制器`

<img src="组成原理.assets/截屏2022-09-08 17.23.03.png" alt="截屏2022-09-08 17.23.03" style="zoom:50%;" />



### 第7章 输入/输出系统

`I/O系统`

* **I/O硬件**

	包括外部设备、IO接口、I/O总线等

* **I/O软件**

	**指令**

	（通常采用I/O指令和通道指令实现主机和I/O设备的信息交换）

	* **I/O指令**

		（CPU执行的指令，用于控制I/O接口或控制通道）

		**指令格式**：1⃣️ **操作码**，识别I/O指令		2⃣️ **命令码**，做什么操作		3⃣️ **设备码**，对哪个设备进行操作

	* **通道指令**

		（通道执行的指令；==通道程序提前编制好放在主存中==）

		在含有通道的计算机中，CPU执行I/O指令对通道发出命令，由通道执行一系列通道指令，代替CPU对I/O设备进行管理

`外部设备`

**显示器**

**灰度级**：指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚

​					逼真，典型的有8位( 256级)、、16位等； n位可以表示$2^n$种不同的亮度或颜色

**显示存储器**（VRAM）：也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中；其存储

​					容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大

​					==$VRAM容量 = 分辨率 \times 灰度级位数；VRAM带宽 = 分辨率\times灰度级位数\times帧频$==

`I/O接口`

**作用**：1⃣️ **数据缓冲**，通过数据缓冲寄存器(DBR)达到主机和外设工作速度的匹配

​				2⃣️ **错误或状态监测**，通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用

​				3⃣️ **控制和定时**，接收从控制总线发来的控制信号、时钟信号

​				4⃣️ **数据格式转换**，串-并、并-串等格式转换		5⃣️ **与主机和设备通信**，实现主机—I/O接口—I/O设备之间的通信

**组成**

**内部接口**：（对应主机侧）内部接口与系统总线相连，实质上是与内存、CPU相连

​							<del>数据的传输方式只能是并行传输</del>（既正确也不正确）

**外部接口**：（对应设备侧）外部接口通过接口电缆与外设相连，外部接口的数据传输可能是串行方式，

​							因此I/O接口需具有串/并转换功能

**工作原理**：1⃣️ **发命令**：发送<u>命令字（控制字）</u>到I/O控制寄存器，向设备发送命令（需要驱动程序的协助）

​						 2⃣️ **读状态**：从状态寄存器读取<u>状态字</u>，获得设备或I/O控制器的状态信息

​						 3⃣️ **读/写数据**：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换

**I/O端口**：I/O控制器中的各种寄存器						**数据线作用**：读写数据、状态字、命令字（控制字）、中断类型号					

**地址线作用**：指明I/O端口										 	**控制线作用**：读/写IO端口的信号、中断请求信号

<img src="组成原理.assets/截屏2022-09-20 17.30.14.png" alt="截屏2022-09-20 17.30.14" style="zoom:38%;" />

**分类**：

* **按数据传送方式**                                    并行接口、串行接口
* **按主机访问I/O设备的控制方式**          程序查询接口、中断接口、DMA接口
* **按功能选择的灵活性**                           可编程接口、不可编程接口

`中断`

**非屏蔽中断**：关中断时也会被响应（如掉电）					**可屏蔽中断**：关中断时不会被响应

**关中断**：为了实现原子操作；==根据PSW中的IF（interrupt flag）标志位==判断是否处于关中断状态

**中断请求标记**：

为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTR，当其状态为“1”时，表示中断源有请求；这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中

<img src="组成原理.assets/截屏2022-09-21 17.34.45.png" alt="截屏2022-09-21 17.34.45" style="zoom:35%;" />

**过程**：1⃣️ **中断请求**，中断源向CPU发送中断请求信号				2⃣️ **中断响应**，判断响应中断的条件（如是否关中断）

​				3⃣️ **中断判优**，多个中断源同时提出请求时通过中断判断优先级逻辑响应一个中断源

​						**优先级**：硬件故障中断属于最高级，其次是软件中断；非屏蔽中断优于可屏蔽中断

​											 DMA请求优于I/O设备传送的中断请求；高速设备优于低速设备

​											 输入设备优于输出设备；实时设备优于普通设备

​						<u>中断判优既可以用硬件实现，也可用软件实现</u>；

​						硬件实现是通过<u>硬件排队器</u>实现的，它既可设置在CPU中，也可分散在各个中断源中；软件实现是通过<u>查询程序</u>实现

<img src="组成原理.assets/截屏2022-09-21 17.37.02.png" alt="截屏2022-09-21 17.37.02" style="zoom:50%;" />

​				4⃣️ **中断处理**，中断隐指令、中断服务程序

​						**中断隐指令**： 1⃣️ **关中断**，为了保护中断现场期间不被新的中断所打断				2⃣️ **保存断点**，保存原程序PC的值

​														3⃣️ **引出中断服务程序**，取出中断服务程序的入口地址（向量地址）并传送给PC

​														如何获取向量地址：软件查询法、硬件向量法（由<u>硬件产生向量地址</u>再由向量地址找到入口地址）

​						**中断服务程序**：1⃣️ **保护现场**，保存通用寄存器和状态寄存器的内容	2⃣️ **中断服务**（设备服务），执行中断处理

​															3⃣️ **恢复现场**，通过出栈指令或取数指令把之前保存的信息送回寄存器中

​															4⃣️ **中断返回**，通过中断返回指令回到原程序断点处

**多重中断**

**单重中断**：执行中断服务程序时不响应新的中断请求			**多重中断**：又称中断嵌套， 执行中断服务程序时可响应新的中断请求

**中断屏蔽技术**：每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个<u>屏蔽字寄存器</u>，屏蔽字寄存器的内容称为<u>屏蔽字</u>

中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，须满足下列条件：

1⃣️ 在中断服务程序中提前设置开中断指令			2⃣️ 优先级别高的中断源有权中断优先级别低的中断源

**屏蔽字设置的规律**：

1⃣️ 一般用'1'表示屏蔽，'0'表示正常申请；

2⃣️ 每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）

3⃣️ 屏蔽字中'1'越多，优先级越高；每个屏蔽字中至少有一个'1'（至少要能屏蔽自身的中断）

<center class="half">
    <img src="组成原理.assets/截屏2022-09-21 18.08.51.png" alt="截屏2022-09-21 18.08.51" style="zoom:40%;" />
    <img src="组成原理.assets/截屏2022-09-21 18.12.52.png" alt="截屏2022-09-21 18.12.52" style="zoom:45%;margin-left:100px" />
</center>
==将比自身优先级高的中断源对应的屏蔽位设为0，将自身或比自身优先级低的中断源对应的屏蔽位设为1==

（下图假设$D>A>C>B$）

<img src="组成原理.assets/截屏2022-09-22 15.24.42.png" alt="截屏2022-09-22 15.24.42" style="zoom:38%;" />

`DMA`

**流程**：CPU向DMA控制器指明要输入还是输出;要传送多少个数据；数据在主存、外设中的地址

​				1⃣️ 接受外设发出的DMA请求（外设传送一个字的请求），并向CPU发出总线请求

​				2⃣️ CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期

​				3⃣️ 确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数

​				4⃣️ 规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作

​				5⃣️ 向CPU报告DMA操作的结束

在DMA传送过程中，<u>DMA控制器将接管CPU的地址总线、数据总线和控制总线</u>，CPU的主存控制信号被禁止使用；而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作

<img src="组成原理.assets/截屏2022-09-22 15.43.11.png" alt="截屏2022-09-22 15.43.11" style="zoom:45%;" />

<img src="组成原理.assets/截屏2022-09-22 15.49.06.png" alt="截屏2022-09-22 15.49.06" style="zoom:40%;" />

**DMA传送方式**：

当I/O设备和CPU同时访问主存，I/O与主机并行工作（程序和传送并行工作），可能发生冲突

* **停止CPU访问主存**

	**优点**：控制简单						**缺点**：未充分发挥CPU对主存的利用率

<img src="组成原理.assets/截屏2022-09-22 16.12.17.png" alt="截屏2022-09-22 16.12.17" style="zoom:50%;" />

* **DMA与CPU交替访存**

	**优点**：不需要总线使用权的申请、建立和归还过程				**缺点**：硬件逻辑更为复杂

<img src="组成原理.assets/截屏2022-09-22 16.12.48.png" alt="截屏2022-09-22 16.12.48" style="zoom:40%;" />

* **周期挪用**（周期窃取）

	DMA访问主存有三种可能：

	1⃣️ CPU此时不访存（不冲突）2⃣️ CPU正访存（存取周期结束后CPU让出总线）3⃣️ CPU与DMA同时请求访存（I/O访存优先）

<img src="组成原理.assets/截屏2022-09-22 16.13.57.png" alt="截屏2022-09-22 16.13.57" style="zoom:45%;" />
