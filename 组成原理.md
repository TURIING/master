### 第1章 计算机系统概述

`计算机的分类与发展方向`

**按指令和数据流分类**

1️⃣ **单指令流和单数据流系统**			==冯·诺伊曼体系结构==	2️⃣ **单指令流和多数据流系统**           阵列处理器和向量处理器系统

3️⃣ **多指令流和单数据流系统**          不存在								  4️⃣ **多指令流和多数据流系统**          多处理器和多计算机系统

**计算机系统的组成**

==硬件系统和软件系统==共同构成一个完整的计算机系统

某功能既可以用软件实现也可以用硬件实现，则称==软件硬件在逻辑上是等效的（等价❌）==

**硬件的发展**

1️⃣ 第一代，电子管时代				2️⃣ 第二代，晶体管时代			==开始出现操作系统==

3️⃣ 第三代，中小规模集成电路时代	==开始有了分时操作系统==		4️⃣ 第四代，大规模、超大规模集成电路时代

**早期的冯·诺伊曼机**

冯·诺伊曼在研究EDVAC机时提出了“==存储程序==”的概念

> 存储程序： 指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直到程序执行结束

**特点**：1⃣️ 计算机硬件系统由==运算器、存储器、控制器、输入设备、输出设备==组成

​				2⃣️ 指令和数据以==同等地位==存储在存储器中，并可按地址寻访			3⃣️ ==指令和数据均用二进制代码表示==

​				4⃣️ 指令由操作码和地址码组成				5⃣️ 指令在存储器内按顺序存放

​				6⃣️  ==以运算器为中心==（**输入、输出设备通过运算器与存储器传送数据**）

**现代计算机结构**

==存储器为中心==、==CPU = 运算器 + 控制器==

`计算机的功能部件`

* **主存储器**

	**组成**：==MAR、MDR、地址译码器==				**工作方式**：==按地址存取方式==（按存储单元的地址进行存取）

	**地址寄存器（MAR）**：==存放访存地址==，经过地址译码后找到所选的存储单元，==MAR位数 = 存储单元的个数==

	**数据寄存器（MDR）**：==用于暂存要从存储器中读或写的信息==，==MDR位数 = 存储字长==

	==现代计算机通常把MAR、MDR集成在CPU中（控制器内）==

	**存储元**：存储二进制的电子元件（电容），每个存储元可存1bit		**存储单元**：每个存储单元存放一串二进制代码

	**存储字**：存储单元中存储的二进制代码						**字长**：计算机每个字包含的位数

	**字**：计算机在进行数据处理，一次存取、加工、传送的数据长度，一个字由多个字节组成；

	​		  ==随架构改变字长==（如64位CPU中一字为64位）

* **运算器**

	**功能**：==用于算术运算（加减乘除）和逻辑运算（与或非）==

	**组成**：1️⃣ **算术逻辑单元（ALU）**，通过内部复杂的电路实现算术运算、逻辑运算

	​				2️⃣ **累加器（ACC）**，用于存放操作数或运算结果	3️⃣ **乘商寄存器（MQ）**，在乘除运算时用于存放操作数或运算结果

	​				4️⃣ **操作数寄存器（X）**，用于存放操作数		5️⃣ **变址寄存器（IX）**				6️⃣ **基址寄存器（BR）**

	​				7️⃣ **程序状态寄存器（PSW、标志寄存器）**

	​						用于存放ALU运算得到的一些标志信息或处理机的状态信息（如结果是否溢出、有无进位或错位、结果是否为负）


* **控制器**

	1⃣️ **控制单元（CU）**， 分析指令，给出控制信号    2⃣️ **程序计数器（PC）**，用于==存放下一条指令的地址==，==有自动加1功能==

	3⃣️ **指令寄存器（IR）**，==存放当前执行的指令==

==运算器和控制器都含有寄存器；寄存器的基本单元是D触发器==

|  是否可见  |                 器件                 |
| :--------: | :----------------------------------: |
|  用户可见  |  ==通用寄存器、程序状态寄存器、PC==  |
| 用户不可见 | ==MAR、MDR、指令寄存器、暂存寄存器== |

`计算机软件的分类`

* **系统软件**

  ==操作系统、数据库管理系统（DBMS）、语言处理程序（编译器）、分布式软件系统==

  ==网络软件系统、标准库程序、服务性程序（链接器、代码调试器）==

  > DBMS： 位于用户和操作系统之间的一层数据管理软件，是系统软件
  >
  > DBS： 指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成

* **应用软件**

`计算机系统的多级层次结构`

<img src="组成原理.assets/截屏2022-04-19 00.31.31.png" alt="截屏2022-04-19 00.31.31" style="zoom: 50%;" />

==下层是上层的基础，上层是下层的扩展==；==上下层是可以分割的，仅有下层而没有上层也是可以的==；==上层是下层的功能实现==

`计算机的性能指标`

* **机器字长**

	（指计算机进行一个整数运算所能处理的二进制数据的位数，衡量计算机并行处理的能力）

	==机器字长等于CPU内部用于整数运算的运算器位数和通用寄存器位数（浮点寄存器位数❌）==

	**指令字长**：一个指令中包含的二进制代码的位数				**存储字长**：一个存储单元存储二进制数据的位数

	**数据字长**：数据总线一次能并行传送信息的位数

* **数据通路带宽**

	（<u>指数据总线一次所能并行传送信息的位数</u>，衡量计算机在功能级部件间传送数据的能力）

	**数据通路**：数据在功能部件之间传送的路径（如内存到CPU）

* **吞吐量**

	（指系统在单位时间内处理请求的数量）

* **响应时间**

	（指用户向计算机发送一个请求，到系统对该请求作出响应并获得所需结果的等待时间）

* **主频和CPU时钟周期**

  **CPU时钟周期**：又称<u>节拍、T周期</u>；==CPU中最小的时间单位==(us、ns)，执行指令的每个动作至少需要1个时钟周期，

  ​								==$CPU时钟周期 = \frac{1}{主频}$==

  **主频（CPU时钟频率）**：主频越高，执行指令的速度越快（Hz）

  **指令周期**：CPU从内存<u>取出一条指令并执行这条指令</u>的时间总和，==通常用若干机器周期来表示==

  **中断周期**：执行一次中断所需要的周期

  **CPU周期**：又称<u>机器周期</u>，从内存取一条指令的最短时间，==包含若干个时钟周期==

  ==不同指令的指令周期可能不同，每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等==

  <img src="组成原理.assets/截屏2022-09-03 14.45.52.png" alt="截屏2022-09-03 14.45.52" style="zoom:60%;" />

* **CPI**

	（执行一条指令所需的时钟周期数）

	对于一个程序或一台机器来说，CPI指该程序或该机器指令集中的所有指令执行所需的**平均时钟周期数**

	==执行一条指令的耗时 = CPI x CPU时钟周期==；==时钟频率并不会影响CPI，但可加快指令的执行速度==

	>**主频高的CPU不一定比主频低的CPU快**
	>
	>如A的主频2GHz，CPI=10；B的主频1GHz，CPI=1
	>
	>**若CPI相同，主频高的CPU也不一定比主频低的CPU快**
	>
	>还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法，而B支持乘法

* **CPU执行时间**

	（运行一个程序所花费的时间）

	==$CPU执行时间 = \frac{CPU时钟周期数}{主频} = \frac{指令条数\times CPI}{主频} = CPI \times 指令条数 \times 时钟周期$==

* **IPS**

	（每秒执行多少条指令）==$IPS = \frac{主频}{CPI}$==

	**MIPS**:==每秒执行多少百万条指令==，==$MIPS = \frac{指令条数}{执行时间\times 10^6} = \frac{主频}{CPI\times 10^6}$==

* **FLOPS**

	（每秒执行多少次浮点运算）==$MFLOPS = \frac{浮点操作次数}{执行时间\times 10^6}$==

	**$$K(10^3)、M（10^6）、G(10^9)、T(10^{12})$$**

**专业术语**

>**基准程序**
>
><u>用来进行性能评价的一组程序</u>
>
>**系列机**： 具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
>
>**兼容**：指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统
>
>**单片机**：<u>CPU+存储器+中断、IO = 单片机</u>

### 第2章 数据的表示和运算

#### 数制与编码

##### 进制的相互转换

`二进制 -> 八进制、十六进制`



`任意进制 -> 十进制`

`十进制 -> 任意进制`

##### 真值和机器数

| 概念 | 描述 |
| :--: | :--: |
|      |      |

#### 定点数的表示与运算

##### 定点数的表示

`无符号数`

(全部二进制位均为数值位)

**范围**:==$$0～2^n-1$$==

==通常只有无符号整数，没有无符号小数==

`补码`

定点整数：==$$[x]_补 = 1,00..00\Rightarrow x=-2^n$$==

定点小数：==$$[x]_补 = 1.00..00 \Rightarrow x=-1$$==

==$$[x]_补 \to [-x]_补$$：符号位、数值位全部取反，末位加1==

`移码`

**常用于表示浮点数的阶码** ==只能表示整数==

==补码的符号位取反即移码==

`与原码的相互转换`

|      |   正数   |                     负数                      |
| :--: | :------: | :-------------------------------------------: |
| 反码 | ==相同== | ==若符号位为1，则符号位不变，数值位全部取反== |
| 补码 | ==相同== |    ==符号位不变，数值位按位取反，末位加1==    |

（字长为n+1）

|      |           整数范围            |               小数范围                |                      真值0                      |
| :--: | :---------------------------: | :-----------------------------------: | :---------------------------------------------: |
| 原码 | ==$$-(2^n-1)\le x\le2^n-1$$== | ==$$-(1-2^{-n})\le x \le 1-2^{-n}$$== | ==不唯一，$$[+0]_原 = 00000,[-0]_原 = 10000$$== |
| 反码 |            同原码             |                同原码                 |  ==不唯一$$[+0]_反 = 00000,[-0]_反 = 11111$$==  |
| 补码 |  ==$$-2^n\le x \le 2^n-1$$==  |     ==$$-1\le x \le 1-2^{-n}$$==      |      ==唯一，$$[+0]_补 =[-0]_补 00000$$==       |
| 移码 |            同补码             |                  无                   |     ==唯一，$$[+0]_移 = [-0]_移 = 10000$$==     |

### 第3章 存储系统

$K:2^{10}、M:2^{20}、G:2^{30}、T:2^{40}$；$1ms=1\times 10^{-3}s、1us=1\times 10^{-6}s；1ns=1\times 10^{-9}s$

`存储器的层次化结构`

**主存—辅存**：==解决了主存容量不够的问题==						**Cache—主存**：==解决了主存和CPU速度不匹配的问题==

主存和Cache之间的数据调动是由==硬件==自动完成的，对==所有程序员是透明的==

主存和辅存之间的数据调动是由==硬件和操作系统==共同完成的，对==应用程序员是透明的==

计算机的存储器采用分级方式是**为了解决容量、速度、价格三者之间的矛盾**

==计算机的存储系统包括CPU内部寄存器、Cache、主存和外存==

`存储器的分类`

**按存储介质分类**

<u>磁表面存储器</u>（磁盘、磁带）、<u>半导体存储器</u>（主存、Cache）、<u>光存储器</u>（光盘）

**按存取方式分类**

* **随机存储器（RAM）**

	存取时间与存储单元的物理位置==无关==

* **只读存储器（ROM）**

	存储器的内容只能随机读出而不能写入		==ROM和RAM均为随机存取且均是半导体存储器==

* **串行访问存储器**

	（读写某个存储单元所需时间与存储单元的物理位置有关）

	* **顺序存取存储器（SAM）**

		读写一个存储单元所需时间==取决于存储单元所在的物理位置==（磁带）；==存取速度慢==

	* **直接存取存储器（DAM）**

		先<u>直接选取信息所在区域，然后按顺序方式存取</u>（磁盘、光盘）；==既有随机存取特性，也有顺序存取特性==

* **相联存储器**

	可以按==内容或地址==检索到存储位置进行读写（快表）

**按信息的可保存性**

* **易失性存储器**				 断电后，存储信息即**消失**（RAM）

* **非易失性存储器**			断电后，存储信息**依然保持**（ROM）
* **破坏性读出**				     信息读出后，原存储信息**被破坏**
* **非破坏性读出**              信息读出后，原存储信息**不被破坏**

`存储器的性能指标`

**存储容量**

==存储容量 = 存储字数 X 字长==（如8Kx8位，即$2^{13}\times 8bit$）

**单位成本**

==$每位价格 = \frac{总成本}{总容量}$==

**存储速度**

==$数据传输率（主存带宽） = \frac{数据的宽度（存储字长）}{存储周期}$==

**存取时间**：指从启动一次存储器操作到完成该操作所经历的时间

**存取周期**：连续两次独立访问存储器操作之间所需的最小时间间隔

<img src="组成原理.assets/截屏2022-06-28 21.16.34.png" alt="截屏2022-06-28 21.16.34" style="zoom: 60%;" />

`主存储器的基本组成`

<img src="组成原理.assets/截屏2022-08-18 17.44.29.png" alt="截屏2022-08-18 17.44.29" style="zoom:60%;" />

**主存储器的基本构成**

<img src="组成原理.assets/截屏2022-08-18 18.01.32.png" alt="截屏2022-08-18 18.01.32" style="zoom:60%;" />

`半导体随机存储器`

==SRAM、DRAM都属于易失性存储器==

 **DRAM**

==用于主存==（**现在的主存通常采用SDRAM**，SDRAM也需要周期性刷新）

存储元使用==栅极电容==存储信息，==破坏性读出==，读出后需要重写信息

==分两次送行列地址==（地址线复用技术，**导致地址线、地址引脚减半**）

**优点**：==容易集成、成本低、集成度高、功耗低==					**缺点**：==存取速度比SRAM慢==（由于读出后需要重写）

**芯片引脚数**：（1024x8位）

==$数据线=数据位数=8；行列选通线：2（片选线用行列选通线代替）；读/写控制线：1或2$==

==$地址线=[log_2(寻址范围)]/2=[log_2(1024)]/2=5；$==

**刷新**：（**刷新周期为2ms，每次刷新一行存储单元**（==刷新以行为单位==））

<u>“刷新”由存储器独立完成，不需要CPU控制</u>；<u>采用行列地址是为了减少选通线的数量</u>

==一次完整的刷新过程占用一个存储周期==

* **集中刷新**

	在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作（称为<u>死时间、访存死区</u>）

* **分散刷新**

  把对每行的刷新分散到各个工作周期中，一个存储器的系统工作周期分为两部分，前半部分用于正常读写，后半部分用于刷新

  ==不存在死时间==

* **异步刷新**

  将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求

  **既可缩短“死时间”，又能充分利用最大刷新间隔为2ms的特点**

**SRAM**

==用于Cache==、存储元使用==双稳态触发器==存储信息，==非破坏性读出==，==同时送行列地址==

**优点**：==存取速度快==												**缺点**：==成本高、集成度低、功耗大==

**芯片引脚数**：（1024x8位）

==$数据线=数据位数=8；片选线：1；读/写控制线：1或2$==

==$地址线=log_2(寻址范围)=log_2(1024)=10；(32K\times 16\Rightarrow 地址线=15)$==

`主存储器与CPU的连接`

**位扩展**

<img src="组成原理.assets/截屏2022-08-18 18.05.35.png" alt="截屏2022-08-18 18.05.35" style="zoom:50%;" />

**字扩展**

* **线选法**

	==$n条线\to n个选片信号$==、电路简单、==地址空间不连续==（有的地址不能使用）

	<img src="组成原理.assets/截屏2022-08-18 18.17.39.png" alt="截屏2022-08-18 18.17.39" style="zoom:50%;" />



* **译码片选法**

	==$n条线\to 2^n个选片信号$==、电路复杂、==地址空间连续==

	<img src="组成原理.assets/截屏2022-08-18 18.14.34.png" alt="截屏2022-08-18 18.14.34" style="zoom:50%;" />

**字位同时扩展**

<img src="组成原理.assets/截屏2022-08-18 18.24.56.png" alt="截屏2022-08-18 18.24.56" style="zoom:50%;" />

**译码器**

<img src="组成原理.assets/截屏2022-08-18 18.27.46.png" alt="截屏2022-08-18 18.27.46" style="zoom:50%;" />

`双端口RAM和多模块存储器`

**双端口RAM**

**双端口存储器具有两套独立读/写口，具有各自的地址寄存器和译码电路**

1⃣️ 两个端口同时对不同地址单元存取数据 🉑️			2⃣️ 两个端口同时对同一地址单元读出数据 🉑️

3⃣️ 两个端口同时对同一地址单元写入数据 （❌写入错误）

4⃣️ 两个端口同时对同一地址单元，一个写入数据，另一个读出数据（❌读出错误）

**解决**：置“忙”信号为0，由判断逻辑决定暂时关闭一个端口，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间短				后再访问

**多体并行存储器**

<u>每个模块都有相同的容量和存取速度</u>

<u>各模块都有独立的读写控制电路、地址寄存器和数据寄存器，它们既能并行又能交叉工作</u>

* **高位交叉编址**

  ==不满足程序局部性原理==

  <img src="组成原理.assets/截屏2022-08-18 21.44.07.png" alt="截屏2022-08-18 21.44.07" style="zoom:50%;" />

* **低位交叉编址**

  ==$连续取n个存储字耗时T+(n-1)r$==（每个存储体存取周期为T，存取时间为r）

  ==$为了使流水线不间断，应保证m\ge \frac{T}{r}$==（m体交叉存储器，每个存储体存取周期为T，<u>存取时间/总线传输周期</u>为r）

  ==满足程序局部性原理==

  <img src="组成原理.assets/截屏2022-08-18 21.44.30.png" alt="截屏2022-08-18 21.44.30" style="zoom:50%;" />
  
  （$蓝色位数为log_2N$，N为芯片数）

**单体多字存储器**

（类似于字扩展法）

==每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字==（不能单独取其中某个字）

`只读存储器`

==CD-ROM是只读型光盘存储器（顺序存取），不属于只读存储器==

**掩模式只读存储器**（MROM）

厂家在生产过程直接写入，==写入以后任何人无法改变内容==

**优点**：==可靠性高，集成度高，价格便宜==				**缺点**：==灵活性差==

**一次可编程只读存储器**（PROM）

允许用户利用专门的设备写入自己的程序，==一旦写入，内容无法改变==

**可擦除可编程只读存储器**（EPROM）

允许用户写入信息，且==可多次重写==；==随机存取==

* **紫外线擦除**（UVEPROM）            需要擦除全部，然后写入

* **电擦除**（EEPROM）                      只需擦除特定的字

**闪速存储器（Flash Memory）**

（U盘、SD卡）<u>存储元由mos管组成</u>

==断电后也能保存信息，且可进行多次快速擦除重写==（读比写快，因为写入需要先擦除原有数据）

**固态硬盘**

<u>由控制单元和存储单元（Flash芯片）构成</u>			==速度快、功耗低，但价格高==

<img src="组成原理.assets/截屏2022-08-19 16.42.23.png" alt="截屏2022-08-19 16.42.23" style="zoom: 55%;" />

`磁盘存储器`

**磁表面存储器**

<u>每次读写只能1bit</u>

**优点**： 1⃣️ ==存储容量大，位价格低== 								   2⃣️ 记录介质可以重复使用

​				 3⃣️ 记录的信息可以长期保存而不丢失	  		 4⃣️ **非破坏性读出**，读出时不需要再生

**缺点**： 1⃣️ ==存取速度慢==		2⃣️ 机械结构复杂		3⃣️ 对工作环境要求较高（容易被磁场干扰）

**磁盘设备的组成**

* **存储区域**

​			一块硬盘有若干个记录面，每个记录面划分为若干条磁道，每条磁道又划分为若干个扇区

​			==扇区（块）是磁盘读写的最小单位（磁盘按块存取）==

​			**磁头数**：即记录面数（一个记录面对应一个磁头），表示硬盘共有多少个磁头

​			**柱面数**：表示硬盘每一面盘片上有多少条磁道

​			**扇区数**：表示每一条磁道上有多少个扇区；==每一个扇区所能存储的二进制数据大小都是相同的==

* **硬盘存储器**

	 1⃣️ **磁盘驱动器**，核心部件是磁头组件和盘片组件

	 2⃣️ **磁盘控制器**，是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA

**磁盘的性能指标**

* **磁盘容量**

	（一个磁盘所能存储的字节总数）

	1⃣️ **非格式化容量**，指磁记录表面可以利用的磁化单元总数

	2⃣️ **格式化容量**，指按照某种特定的记录格式所能存储信息的总量；一般<u>非格式化容量 > 格式化容量</u>

* **记录密度**

	1⃣️ **道密度**，沿磁盘半径方向单位长度上的磁道数（如60道/cm）

	2⃣️ **位密度**，磁道单位长度上所能记录的二进制代码位数（如600bit/cm）

	​       ==每个磁道的位密度都不同，越内侧的磁道位密度越大==（由于**所有磁道记录的信息量是相等的**，但磁道半径不一样）

	3⃣️ **面密度**，道密度与位密度的乘积

* **平均存取时间**

	==$平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）$==

* **数据传输率**

	（磁盘存储器在单位时间内向主机传送数据的字节数）

	==$数据传输率=rN$==（磁盘转速为r（转/秒），每条磁道容量为N个字节）

**磁盘地址**

<img src="组成原理.assets/截屏2022-08-19 16.18.13.png" alt="截屏2022-08-19 16.18.13" style="zoom:50%;" />

**硬盘的工作过程**

硬盘的主要操作是寻址、读盘、写盘；每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字；硬盘属于机械式部件，其==读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据==

**磁盘阵列**

廉价冗余磁盘阵列（RAID），是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性（**编号中的数值越大可靠性越高**）和安全性

1⃣️ **RAID0**：无冗余和无校验的磁盘阵列（==没有容错能力==；类似低位交叉编址的多体存储器）

<img src="组成原理.assets/截屏2022-08-19 16.33.08.png" alt="截屏2022-08-19 16.33.08" style="zoom:45%;" />

2⃣️ **RAID1**：镜像磁盘阵列（存两份数据，==意味着容量减少一半==）

<img src="组成原理.assets/截屏2022-08-19 16.34.04.png" alt="截屏2022-08-19 16.34.04" style="zoom:45%;" />

3⃣️ **RAID2**：采用纠错的海明码的磁盘阵列

（逻辑上连续的几个bit物理上分散存储在各个盘中，4bit信息位+3bit海明校验位，可纠正一位错）

<img src="组成原理.assets/截屏2022-08-19 16.30.57.png" alt="截屏2022-08-19 16.30.57" style="zoom:40%;" />

4⃣️ **RAID3**：位交叉奇偶校验的磁盘阵列

5⃣️ **RAID4**：块交叉奇偶校验的磁盘阵列

6⃣️ **RAID5**：无独立校验的奇偶校验磁盘阵列

`Cache的概念和原理`

**“Cache—主存”系统的平均访问时间**：

<u>不同时访问</u>：==$t=Ht_c+(1-H)(t_c+t_m)$==（$H为命中率，t_c为访问一次Cache所需时间，t_m为访问一次主存所需时间$）

<u>同时访问</u>：==$t=Ht_c+(1-H)t_m$==

==主存与Cache之间以块为单位进行数据交换==

`Cache和主存的映射方式`

* **全相联映射**

  **访存过程**：（CPU访问主存地址1...1101001110）

  1⃣️ 对比Cache中所有块的标记和主存地址的前22位  2⃣️ 若标记匹配且有效位 = 1，则命中 ,访问块内地址为001110的单元

  3⃣️ 若未命中或有效位 = 0， 则正常访问主存

  <img src="组成原理.assets/截屏2022-08-19 17.15.04.png" alt="截屏2022-08-19 17.15.04" style="zoom:45%;" />

  **优点**：<u>Cache存储空间利用充分，命中率高</u>

  **缺点**：<u>查找标记最慢</u>

  **替换算法**：<u>Cache完全满了才需要替换</u>，需要在<u>全局</u>选择替换哪一块

* **直接映射**

  ==$主存块在Cache中的位置=主存块号\%Cache总块数$==

  ==$若Cache总块数=2^n，则主存块号末尾n位直接反映它在Cache中的位置（由于主存块号\%2^n相当于留下最后n位二进制数）$==

  ==因此只需主存块号的其余位作为标记即可==

  <img src="组成原理.assets/截屏2022-08-19 17.54.45.png" alt="截屏2022-08-19 17.54.45" style="zoom:45%;" />

  **访存过程**：（CPU访问主存地址01000001110 ）

  1⃣️ 根据主存块号的后3位确定Cache行

  2⃣️ 若主存块号的前19位与Cache标记匹配且有效位 = 1，则命中，访问块内地址为001110的单元

  3⃣️ 若未命中或有效位 = 0，则正常访问主存

  **优点**：<u>查找标记速度最快</u>

  **缺点**：<u>灵活性差、Cache存储空间利用不充分，命中率低</u>

  **替换算法**：<u>不需要替换算法</u>，如果对应位置非空，则毫无选择地直接替换

* **组相联映射**

	==$所属分组=主存块号\%分组数$==

	==$若Cache总组数=2^n，则主存块号末尾n位直接反映它在Cache中的组号，因此只需主存块号的其余位作为标记即可$==

	<img src="组成原理.assets/截屏2022-08-19 17.56.47.png" alt="截屏2022-08-19 17.56.47" style="zoom:45%;" />

	**访存过程**：（CPU访问主存地址1...1101001110）

	1⃣️ 根据主存块号的后2位确定所属分组号

	2⃣️ 若主存块号的前20位与分组内的某个标记匹配且有效位 = 1，则Cache命中，访问块内地址为001110的单元
	3⃣️ 若未命中或有效位 = 0，则正常访问主存

	<img src="组成原理.assets/截屏2022-08-19 18.02.18.png" alt="截屏2022-08-19 18.02.18" style="zoom:45%;" />

	**优点**：<u>另外两种方法的折中，综合效果较好</u>
	
	**替换算法**：<u>分组内满了才需要替换</u>，需要在<u>分组内</u>选择替换哪一块

`Cache替换算法`

* **随机算法**（RAND）

	（若Cache已满，则随机选择一块替换）

	==实现简单、命中率低（没考虑到局部性原理）==

* **先进先出算法**（FIFO）

	（若Cache已满，则替换最先被调入的Cache块）

	==实现简单、没考虑到局部性原理==、==会出现抖动现象==（刚被替换的块很快又被调入）

* **近期最少使用算法**（LRU）

	（为每一个Cache块设置一个计数器，用于记录每个Cache块已经多久没被访问了，当Cache满后替换计数器最大的）

	1⃣️ 未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1

	2⃣️ 命中时，所命中的行的计数器清零，比其低的计数器加1,其余不变

	3⃣️ 未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1

	==$若Cache块的总数为2^n，则计数器只需n位$==、==Cache装满后所有计数器的值一定不重复==

	<img src="组成原理.assets/截屏2022-08-20 14.52.20.png" alt="截屏2022-08-20 14.52.20" style="zoom:50%;" />

	==基于局部性原理、命中率高==、==若被频繁访问的主存块数量 > Cache行的数量，则可能发生抖动==

* **最不经常使用算法**（LFU）

	（为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后替换计数器最小的）

	新调入的块的计数器为0，之后每被访问一次计数器+1；需要替换时，选择计数器最小的一行

	（若有多个计数器最小的行，可按行号递增或FIFO策略进行选择）

	==不遵循局部性原理==（曾经被经常访问的主存块在未来不一定会用到）、==实际运行效果不如LRU==

`Cache写策略`

* **写命中**

	* **写回法**

		（当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块**被换出时**才写回主存）

		需要增加一位==脏位==表示是否被修改过

	* **全写法**（写直通法）

		（当CPU对Cache写命中时，必须把数据**同时写入**Cache和主存，一般使用写缓冲）

* **写不命中**

	* **写分配法**

		（当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改；通常**搭配写回法**使用）

	* **非写分配法**

		（当CPU对Cache写不命中时，**只写入主存，不调入Cache**；**搭配全写法使用**）

`多级Cache`

<u>离CPU越近，速度越快，容量越小；离CPU越远，速度越慢，容量越大</u>

==各级Cache之间采用全写法+非写分配法；Cache—主存之间采用写回法+写分配法==



### 第5章 中央处理器

`CPU的功能和基本结构`

**CPU的功能**

1️⃣ **指令控制**，完成取指令、分析指令和执行指令的操作，即程序的顺序控制

2️⃣ **操作控制**，一条指令的功能往往是由若干操作信号的组合来实现的；CPU管理并产生由内存取出的每条指令的操作信号，

​		把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作

3️⃣ **时间控制**，对各种操作加以时间上的控制；时间控制要为每条指令按时间顺序提供应有的控制信号

4️⃣ **数据加工**，对数据进行算术和逻辑运算

5️⃣ **中断处理**，对计算机运行过程中出现的异常情况和特殊请求进行处理

**CPU的基本机构**

* **运算器**

	**组成**：1️⃣ **算术逻辑单元**：主要功能是进行算术/逻辑运算

	​				2️⃣ **通用寄存器组**：如AX、BX、 CX、DX、SP，用于存放操作数和各种地址信息

	​				3️⃣ **暂存寄存器**：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容

	​					（配合CPU内部单总线方式）

	​				4️⃣ **累加寄存器**：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算

	​				5️⃣ **程序状态字寄存器**：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，

	​						PSW中的这些位参与并决定微操作的形成

	​				6️⃣ **移位器**：对运算结果进行移位运算				7️⃣ **计数器**：控制乘除运算的操作步数

* **控制器**

	（协调并控制计算机各部件执行程序的指令序列，**基本功能包括取指令、分析指令、执行指令**）

	**取指令**：自动形成指令地址；自动发出取指令的命令

	**分析指令**：操作码译码（分析本条指令要完成什么操作）；产生操作数的有效地址

	**执行指令**：根据分析指令得到的操作命令和操作数地址形成操作信号控制序列，控制运算器、存储器及I/O设备完成相应的操作

	**组成**：1️⃣ 程序计数器（PC）：用于指出下一条指令在主存中的存放地址

	​				2️⃣ 指令寄存器（IR）：用于保存当前正在执行的那条指令

	​				3️⃣ 指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号

	​				4️⃣ 微操作信号发生器：根据IR的内容、PSW的内容及时序信号，产生控制整个计算机系统所需的

	​						各种控制信号，其结构有组合逻辑型和存储逻辑型两种

	​				5️⃣ 时序系统：用于产生各种时序信号，它们都是由统一时钟(CLOCK) 分频得到

	​				6️⃣ 存储器地址寄存器（MAR）：用于存放所要访问的主存单元的地址

	​				7️⃣ 存储器数据寄存器（MDR）：用于存放向主存写入的信息或从主存中读出的信息



`数据通路`

**数据通路的基本结构**

* **专用数据通路方式**

	（根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，即每个寄存器有多条线连接目标器件）

	**优点**：==性能较高，基本不存在数据冲突现象==				**缺点**：==结构复杂，硬件量大， 不易实现==

	> 如果直接用导线连接，相当于多个寄存器同时并且一直向ALU传输数据
	>
	> **解决方法1**：使用多路选择器，根据控制信号选择一路输出
	>
	> **解决方法2**：使用三态门可以控制每一路是否输出
	>
	> ​							（如R0out为1时 R中的数据输出到A端；R0out为0时，R中的数据无法输出到A端）

	<img src="组成原理.assets/截屏2022-09-03 14.04.17.png" alt="截屏2022-09-03 14.04.17" style="zoom:50%;" />

* **CPU内部单总线方式**

	（将所有寄存器的输入端和输出端都连接到一条公共的通路上）

	**优点**：==结构简单，容易实现==					**缺点**：==数据传输存在较多冲突的现象，性能较低==

	<img src="组成原理.assets/截屏2022-09-03 14.13.45.png" alt="截屏2022-09-03 14.13.45" style="zoom:50%;" />
