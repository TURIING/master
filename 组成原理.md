### 第1章 计算机系统概述

`计算机的分类与发展方向`

**按指令和数据流分类**

1️⃣ **单指令流和单数据流系统**			==冯·诺伊曼体系结构==	2️⃣ **单指令流和多数据流系统**           阵列处理器和向量处理器系统

3️⃣ **多指令流和单数据流系统**          不存在								  4️⃣ **多指令流和多数据流系统**          多处理器和多计算机系统

**计算机系统的组成**

==硬件系统和软件系统==共同构成一个完整的计算机系统

某功能既可以用软件实现也可以用硬件实现，则称==软件硬件在逻辑上是等效的（等价❌）==

**硬件的发展**

1️⃣ 第一代，电子管时代				2️⃣ 第二代，晶体管时代			==开始出现操作系统==

3️⃣ 第三代，中小规模集成电路时代	==开始有了分时操作系统==		4️⃣ 第四代，大规模、超大规模集成电路时代

**早期的冯·诺伊曼机**

冯·诺伊曼在研究EDVAC机时提出了“==存储程序==”的概念；			**基本工作方式**：==控制流驱动方式==

> 存储程序： 指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直到程序执行结束

==冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是指令周期的不同阶段==

**特点**：1⃣️ 计算机硬件系统由==运算器、存储器、控制器、输入设备、输出设备==组成

​				2⃣️ 指令和数据以==同等地位==存储在存储器中，并可按地址寻访			3⃣️ ==指令和数据均用二进制代码表示==

​				4⃣️ 指令由操作码和地址码组成				5⃣️ 指令在存储器内按顺序存放

​				6⃣️  ==以运算器为中心==（**输入、输出设备通过运算器与存储器传送数据**）

**现代计算机结构**

==存储器为中心==、==CPU = 运算器 + 控制器==

`计算机的功能部件`

<img src="组成原理.assets/截屏2022-10-17 11.02.01.png" alt="截屏2022-10-17 11.02.01" style="zoom:40%;" />

* **主存储器**

  **组成**：==MAR、MDR、地址译码器==				**工作方式**：==按地址存取方式==（按存储单元的地址进行存取）

  **地址寄存器（MAR）**：==存放访存地址==，经过地址译码后找到所选的存储单元，==MAR位数 = 存储单元的个数==

  **数据寄存器（MDR）**：==用于暂存要从存储器中读或写的信息==，==MDR位数 = 存储字长==

  ​												  ==MDR位数可以不等于数据字长==（当MDR > 数据字长时，数据可以分多次发送）

  ​										 		 ==MDR位数可以不等于指令寄存器IR的位数==（当IR位数 > MDR时，数据可以分多次发送）

  ​												  ==现代计算机通常把MAR、MDR集成在CPU中（控制器内）==

  **存储元**：存储二进制的电子元件（电容），每个存储元可存1bit		**存储单元**：每个存储单元存放一串二进制代码

  **存储字**：存储单元中存储的二进制代码						**字长**：计算机每个字包含的位数

  **字**：计算机在进行数据处理，一次存取、加工、传送的数据长度，一个字由多个字节组成；

  ​		  ==随架构改变字长==（如64位CPU中一字为64位）

* **运算器**

	**功能**：==用于算术运算（加减乘除）和逻辑运算（与或非）==

	**组成**：1️⃣ **算术逻辑单元（ALU）**，通过内部复杂的电路实现算术运算、逻辑运算

	​				2️⃣ **累加器（ACC）**，用于存放操作数或运算结果	3️⃣ **乘商寄存器（MQ）**，在乘除运算时用于存放操作数或运算结果

	​				4️⃣ **操作数寄存器（X）**，用于存放操作数		5️⃣ **变址寄存器（IX）**				6️⃣ **基址寄存器（BR）**

	​				7️⃣ **程序状态寄存器（PSW、标志寄存器）**

	​						用于存放ALU运算得到的一些标志信息或处理机的状态信息（如结果是否溢出、有无进位或错位、结果是否为负）
	
	​				8️⃣ **暂存寄存器**		9️⃣ **移位器**		🔟 **计数器**


* **控制器**

	1⃣️ **控制单元（CU）**， 分析指令，给出控制信号    2⃣️ **程序计数器（PC）**，用于==存放下一条指令的地址==，==有自动加1功能==

	3⃣️ **指令寄存器（IR）**，==存放当前执行的指令==、==IR位数 = 指令字长==

==运算器和控制器都含有寄存器；寄存器的基本单元是D触发器==

|  是否可见  |                 器件                 |
| :--------: | :----------------------------------: |
|  用户可见  |  ==通用寄存器、程序状态寄存器、PC==  |
| 用户不可见 | ==MAR、MDR、指令寄存器、暂存寄存器== |

`计算机软件的分类`

* **系统软件**

  ==操作系统、数据库管理系统（DBMS）、语言处理程序（编译器）、分布式软件系统==

  ==网络软件系统、标准库程序、服务性程序（链接器、代码调试器）==

  > 数据库管理系统（DBMS）： 位于用户和操作系统之间的一层数据管理软件，是==系统软件==
  >
  > 数据库系统（DBS）： 指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成，是==应用软件==

* **应用软件**

`计算机系统的多级层次结构`

<img src="组成原理.assets/截屏2022-04-19 00.31.31.png" alt="截屏2022-04-19 00.31.31" style="zoom: 50%;" />

==下层是上层的基础，上层是下层的扩展==；==上下层是可以分割的，仅有下层而没有上层也是可以的==；==上层是下层的功能实现==

`编译程序和解释程序`

==编译程序和解释程序的作用都是将高级语言程序转换成机器语言程序==

==解释程序将源程序翻译成机器语言，并且翻译一条以后，立即执行这条语句==

`计算机的性能指标`

* **机器字长**

  （指计算机==进行一个整数运算所能处理的二进制数据的位数==，衡量计算机并行处理的能力）

  ==机器字长等于CPU内部用于整数运算的运算器位数和通用寄存器位数（浮点寄存器位数❌）==

  **指令字长**：一个指令中包含的二进制代码的位数				**存储字长**：一个存储单元存储二进制数据的位数

  **数据字长**：数据总线一次能并行传送信息的位数

  ==机器字长、指令字长、存储字长在数值上可能不相等==

* **数据通路带宽**

	（<u>指数据总线一次所能并行传送信息的位数</u>，衡量计算机在功能级部件间传送数据的能力）

	**数据通路**：数据在功能部件之间传送的路径（如内存到CPU）

* **吞吐量**

  （指系统在单位时间内处理请求的数量）

  ==从用户观点看，评价计算机系统性能的综合参数是吞吐率==

* **响应时间**

	（指用户向计算机发送一个请求，到系统对该请求作出响应并获得所需结果的等待时间）

* **主频和CPU时钟周期**

  **CPU时钟周期**：又称<u>节拍、T周期</u>；==CPU中最小的时间单位==(us、ns)，执行指令的每个动作至少需要1个时钟周期，

  ​								==$CPU时钟周期 = \frac{1}{主频}$==

  **主频（CPU时钟频率）**：主频越高，执行指令的速度越快（Hz）

* **CPI**

	（执行一条指令所需的时钟周期数）

	对于一个程序或一台机器来说，CPI指该程序或该机器指令集中的所有指令执行所需的**平均时钟周期数**

	==执行一条指令的耗时 = CPI x CPU时钟周期==；==时钟频率并不会影响CPI，但可加快指令的执行速度==

	>**主频高的CPU不一定比主频低的CPU快**
	>
	>如A的主频2GHz，CPI=10；B的主频1GHz，CPI=1
	>
	>**若CPI相同，主频高的CPU也不一定比主频低的CPU快**
	>
	>还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法，而B支持乘法

* **CPU执行时间**

	（运行一个程序所花费的时间）

	==$CPU执行时间 = \frac{CPU时钟周期数}{主频} = \frac{指令条数\times CPI}{主频} = CPI \times 指令条数 \times 时钟周期$==

* **IPS**

	（每秒执行多少条指令）==$IPS = \frac{主频}{CPI}$==

	**MIPS**:==每秒执行多少百万条指令==，==$MIPS = \frac{指令条数}{执行时间\times 10^6} = \frac{主频}{CPI\times 10^6}$==

* **FLOPS**

	（每秒执行多少次浮点运算）==$MFLOPS = \frac{浮点操作次数}{执行时间\times 10^6}$==

	==用于评估科学计算的计算机浮点运算性能==
	
	**$$K(10^3)、M（10^6）、G(10^9)、T(10^{12})$$**

<u>当前设计高性能计算机的重要技术途径是采用并行处理技术</u>

**专业术语**

>**基准程序**
>
><u>用来进行性能评价的一组程序</u>（鲁大师）
>
>**系列机**： 具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列
>
>**兼容**：指计算机==软件或硬件==的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统（在==同一系列不同型号==的计算机间通用）
>
>**单片机**：<u>CPU + 存储器 + 中断、IO = 单片机</u>

### 第2章 数据的表示和运算

`进制`

**进制的相互转换**

* **二进制 <—> 八进制、十六进制**

	$二进制\to 八进制：1111000010.01101\Rightarrow 001\ 111\ 000\ 010.011\ 010\Rightarrow 1702.32$（3位一组，每组转换成八进制符号）

	$二进制\to 十六进制：1111000010.01101\Rightarrow 0011\ 1100\ 0010.0110\ 1000\Rightarrow 3c2.68$（4位一组，每组转换成十六进制符号）

	$八进制\to 二进制：(251.5)_8\Rightarrow 010\ 101\ 001.101$（每位八进制对应成3位二进制）

	$十六进制\to 二进制：(AE86.1)_{16}\Rightarrow 1010\ 1110\ 0110.0001$（每位十六进制对应成4位二进制）

* **任意进制 —> 十进制**

	$二进制：10010010.110\Rightarrow 1\times 2^7+1\times 2^4+1\times 2^1+1\times 2^{-1}+1\times 2^{-2}=146.75$

	$八进制：251.5\Rightarrow 2\times 8^2+5\times 8^1+1\times 8^0+5\times 8^{-1}= 168.625$

	$十六进制：AE86.1\Rightarrow 10\times 16^3 + 14\times 16^2+8\times 16^1+6\times 16^0+1\times 16^{-1} = 44678.0625$

* **十进制 -> 任意进制**

	$十进制\to 二进制：75\Rightarrow 1001011；0.3\Rightarrow 0.01..B$

	<img src="组成原理.assets/截屏2022-09-28 09.03.02.png" alt="截屏2022-09-28 09.03.02" style="zoom:40%;" />
	
	<img src="组成原理.assets/截屏2022-09-28 09.10.09.png" alt="截屏2022-09-28 09.10.09" style="zoom:40%" />

**BCD码**

* **8421码**（8、4、2、1分别对应每一位的权值）

	$十进制\to 二进制：985\Rightarrow 1001\ 1000\ 0101$

	$加法：5+8=13\Rightarrow 0101+1000=1101+0110=1\ 0011=0001\ 0011$（若加法结果为10～15，则+6（0110）修正）

	<img src="组成原理.assets/截屏2022-09-28 09.38.58.png" alt="截屏2022-09-28 09.38.58" style="zoom:33%;" />

* **余3码**（8421码 + 0011）

	<img src="组成原理.assets/截屏2022-09-28 09.39.45.png" alt="截屏2022-09-28 09.39.45" style="zoom:33%;" />

* **2421码**（改变权值定义；2、4、2、1分别对应每一位的权值）

	<img src="组成原理.assets/截屏2022-09-28 09.43.33.png" alt="截屏2022-09-28 09.43.33" style="zoom:33%;" />

	==表示0～4时，最高位为0；表示5～9时，最高位为1==

`定点数的表示与运算`

**无符号整数**

（全部二进制位均为数值位）

==$n\ bit无符号整数表示范围0～2^n-1，超出则溢出$==；==通常只有无符号整数，没有无符号小数==

**加法**：从最低位开始，按位相加，并往更高位进位

**减法**： 1⃣️ ==被减数”不变，“减数” 全部位按位取反、末位+1，减法变加法==

​				2⃣️ <u>从最低位开始，按位相加，并往更高位进位</u>

<img src="组成原理.assets/截屏2022-09-28 09.57.06.png" alt="截屏2022-09-28 09.57.06" style="zoom:28%;" />

**有符号整数**（定点小数的各种操作均与定点整数一致）

**定点整数的编码表示**：<u>原码、反码、补码、移码</u>               **定点小数的编码表示**：<u>原码、反码、补码</u>

* **原码**                    **缺点**：符号位不能参与运算

* **补码**

  （符号位可以参与运算）

  **补码的加法**：==从最低位开始，按位相加（符号位参与运算）, 并往更高位进位==

  **补码的减法**：$[A]_补-[B]_补=[A]_补+[-B]_补$

  ​                         1⃣️ ==被减数”不变，“减数” 全部位按位取反、末位+1，减法变加法==

  ​				            2⃣️ <u>从最低位开始，按位相加，并往更高位进位</u>

  **补码加减运算器**：

  ==适用于补码加减运算以及无符号整数的加减法==；==补码加减是否溢出根据OF判断，无符号数加减是否溢出根据CF判断==

  <img src="组成原理.assets/截屏2022-10-27 11.05.40.png" alt="截屏2022-10-27 11.05.40" style="zoom:33%;" />

  <img src="组成原理.assets/截屏2022-10-27 11.03.28.png" alt="截屏2022-10-27 11.03.28" style="zoom: 33%;" />

  ==$$[x]_补 \to [-x]_补$$：符号位、数值位全部取反，末位加1==

  **定点整数**：==$$[x]_补 = 1,00..00\Rightarrow x=-2^n$$==

  **定点小数**：==$$[x]_补 = 1.00..00 \Rightarrow x=-1$$==

* **移码**

	（将补码的符号位取反即移码）

	常用于表示浮点数的阶码； ==只能用于表示整数==

**原码、反码、补码的相互转换**：

* **正数**               ==全部相同==

* **负数**

	$原码\Leftrightarrow 反码$：==符号位不变，数值位取反==				$反码\Rightarrow 补码$：==末位 + 1==

	$原码\Leftrightarrow 补码（机算）$：==符号位不变，数值位取反，末位 + 1== 	

	$原码\Leftrightarrow 补码（手算）$​：==从右往左找到第一个1, 这个1左边的所有“数值位”按位取反==

（字长为n+1，定点小数真值0的表示均与定点整数一致）

|      |           整数范围            |               小数范围                |                      真值0                      |
| :--: | :---------------------------: | :-----------------------------------: | :---------------------------------------------: |
| 原码 | ==$$-(2^n-1)\le x\le2^n-1$$== | ==$$-(1-2^{-n})\le x \le 1-2^{-n}$$== | ==不唯一，$$[+0]_原 = 00000,[-0]_原 = 10000$$== |
| 反码 |            同原码             |                同原码                 |  ==不唯一$$[+0]_反 = 00000,[-0]_反 = 11111$$==  |
| 补码 |  ==$$-2^n\le x \le 2^n-1$$==  |     ==$$-1\le x \le 1-2^{-n}$$==      |      ==唯一，$$[+0]_补 =[-0]_补 00000$$==       |
| 移码 |            同补码             |                  无                   |     ==唯一，$$[+0]_移 = [-0]_移 = 10000$$==     |

**定点小数扩展位数时与定点整数不一样**：

<img src="组成原理.assets/截屏2022-09-28 18.34.30.png" alt="截屏2022-09-28 18.34.30" style="zoom:33%;" />

`溢出判断`

（只有“正数+正数”才会上溢；只有“负数+负数”才会下溢；双符号位补码又称模4补码，单符号位补码又称模2补码）

* **一位符号位**

	1⃣️ $设A的符号为A_s，B的符号为B_s， 运算结果的符号为S_s，则溢出逻辑表达式为V=A_sB_s\bar{S_s}+\bar{A_s}\bar{B_s}S_s$
			若V = 0，表示无溢出；若V = 1，表示有溢出

	2⃣️ $设符号位的进位为C_s，最高数值位的进位C_1，则V=C_s\oplus C_1;若V = 0，表示无溢出；若V = 1，表示有溢出$

	​		==$C_SC_1=01时，正溢出；C_sC_1=10时，负溢出$==

* **双符号位**

	$设两个符号位为S_1、S_2，则V=S_1\oplus S_2，若V = 0，表示无溢出；若V = 1，表示有溢出$

	<img src="组成原理.assets/截屏2022-10-29 16.00.11.png" alt="截屏2022-10-29 16.00.11" style="zoom:33%;" />

==模4补码比模2补码更易检查加减运算中的溢出问题==

==存储模4补码仅需一个符号位==（两个符号位总是相同的）；只在把符号位送往ALU加减运算时，才把值同时送到ALU的双符号位）



`移位运算`

* **算数移位**

	（==符号位保持不变，仅对数值位进行移位==）

	* **原码**

		**右移**：高位补0，低位舍弃；若舍弃的位=0，则相当于除2；若舍弃的位≠0，则会丢失精度

		**左移**：低位补0，高位舍弃；若舍弃的位=0，则相当于乘2；若舍弃的位≠0，则会出现严重误差

		<img src="组成原理.assets/截屏2022-10-25 09.11.13.png" alt="截屏2022-10-25 09.11.13" style="zoom:28%;" />

	* **反码**

		

		* **正数**               正数的反码算数移位与原码相同
		* **负数**              **右移**：高位补1， 低位舍弃                **左移**：低位补1，高位舍弃（由于负数的反码数值位与原码相反）

	* **补码**

		* **正数**               正数的补码算数移位与原码相同

		* **负数**              **右移**：高位补1， 低位舍弃                **左移**：低位补0，高位舍弃

			（由于负数补码中，最右边的1及其右边同原码，最右边的1的左边同反码）

			<img src="组成原理.assets/截屏2022-10-25 09.26.01.png" alt="截屏2022-10-25 09.26.01" style="zoom:25%;" />

* **逻辑移位**

	（不区分符号位与数值位，所有位都移动）

	**右移**：高位补0，低位舍弃           **左移**：低位补0，高位舍弃

	<img src="组成原理.assets/截屏2022-10-25 09.34.46.png" alt="截屏2022-10-25 09.34.46" style="zoom:25%;" />

* **循环移位**

	**不带进位位**：用移出的位补上空缺                **带进位位**：移出的位放到进位位，原进位位补上

	<img src="组成原理.assets/截屏2022-10-25 09.39.43.png" alt="截屏2022-10-25 09.39.43" style="zoom:33%;" />
	
	（注意：不管带不带进位位，不管左移还是右移，进位位都会被更新）

`乘法`

* **原码一位乘法**

	（设机器字长位n+1位，包含1位符号位，$[x]_原=1.1101，[y]_原=0.1011$）

	<img src="组成原理.assets/截屏2022-10-25 09.59.07.png" alt="截屏2022-10-25 09.59.07" style="zoom:25%;" />
	
	​    <img src="组成原理.assets/截屏2022-10-25 10.02.51.png" alt="截屏2022-10-25 10.02.51" style="zoom:28%"/>
	
	1⃣️ 开始前，先将ACC置0              2⃣️ 将<u>被乘数、乘数取绝对值</u>分别存入X、MQ中
	
	3⃣️ 若当前位（即MQ的最低位）=1，则ACC加上被乘数；若当前位=0，则ACC加上0
	
	4⃣️ ACC与MQ联合起来一起逻辑右移一位，高位补0           5⃣️ 重复n次         
	
	6⃣️ 将被乘数、乘数的符号位异或替换掉ACC左边第一位，图中红色部分即乘法结果
	
* **补码一位乘法**

	<img src="组成原理.assets/截屏2022-10-25 10.24.42.png" alt="截屏2022-10-25 10.24.42" style="zoom:33%;" />

	$设机器字长为5位（含1位符号位，n=4），x=-0.1101, y=+0.1011，[x]_补=11.0011，[-x]_补=00.1101， [y]_补=0.1011$

	$辅助位-MQ中最低位=1时，(ACC)+[x]_补、辅助位-MQ中最低位=0时，(ACC)+0、辅助位-MQ中最低位=-1时，(ACC)+[-x]_补$

	符号位、数值位都是由<u>被乘数和乘数进行n轮加法、移位</u>，==最后再多来一次加法==

	每次移位是补码的算数右移；乘数的符号位参与运算

`除法`

* **原码（恢复余数法）**

  $设机器字长为5位（含1位符号位，n=4），x=0.1011, y=0.1101，|x|=0.1011, |y|=0.1101, [|y|]_补=0.1101, [-|y|]_补=1.0011$

  <img src="组成原理.assets/截屏2022-10-29 14.39.51.png" alt="截屏2022-10-29 14.39.51" style="zoom:28%;padding-left:0px" />

  ​    <img src="组成原理.assets/截屏2022-10-29 14.50.47.png" alt="截屏2022-10-29 14.50.47" style="zoom:30%" />

  1⃣️ 开始前，先将MQ置0              2⃣️ 将被除数、除数取绝对值分别存入ACC、X中


  3⃣️ $ACC+[-|y|]_补送至ACC$，同时MQ最低位置1，若ACC中为负数，则$ACC+[|y|]_补$，MQ最低位置0

  4⃣️ 将ACC、MQ联合起来逻辑左移一位，低位补0           5⃣️重复n次

  6⃣️ 将被除数、除数的符号位异或替换掉MQ左边第一位，MQ即商；余数需要乘以$2^{-n}$

  ==左移n次，上商n+1次，最后一次上商余数不左移==（若最后一步，余数为负，也需要恢复余数并商0）

  <img src="组成原理.assets/截屏2022-10-29 14.57.52.png" alt="截屏2022-10-29 14.57.52" style="zoom:30%;" />

* 原码（不恢复余数法、加减交替法）

	<img src="组成原理.assets/截屏2022-10-29 15.12.11.png" alt="截屏2022-10-29 15.12.11" style="zoom:30%;" />

	**加减次数**：==n+1 或 n+2==          **移位次数**：==n==

	==只在最终余数为负时，才需要恢复余数==

`算术逻辑单元（ALU）`

由<u>组合逻辑电路</u>构成的，==最基本的部件是并行加法器==

<img src="组成原理.assets/截屏2022-10-26 11.40.13.png" alt="截屏2022-10-26 11.40.13" style="zoom:30%;" />

`电路的基本原理、加法器设计`

**一位全加器**

<img src="组成原理.assets/截屏2022-10-27 09.34.39.png" alt="截屏2022-10-27 09.34.39" style="zoom:30%;" />

​    <img src="组成原理.assets/截屏2022-10-27 09.35.09.png" alt="截屏2022-10-27 09.35.09" style="zoom:33%" />


**进位产生的原因**：==1⃣️ A和B都为1   2⃣️ AB其中一个为1且进位为1==（其中1⃣️为进位生成信号，2⃣️为进位传递信号）

**串行加法器**

只有一个全加器，数据逐位串行送入加法器中进行运算；进位触发器用来寄存进位信号，以便参与下一次运算

如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器

<img src="组成原理.assets/截屏2022-10-27 09.40.36.png" alt="截屏2022-10-27 09.40.36" style="zoom:33%;" />

**串行进位的并行加法器**

<img src="组成原理.assets/截屏2022-10-27 09.42.31.png" alt="截屏2022-10-27 09.42.31" style="zoom:33%;" />

串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的

<u>在串行进位的并行加法器中，影响加法器运算速度的关键因素是进位传递延迟</u>

**采用并行进位的目的**：<u>提高加法器运算速度</u>

`C语言类型转换`

==C语言中定点整数是用“补码”存储的==

$无符号\Leftrightarrow 有符号$：==不改变数据内容，只改变解释方式==

$长整数\Rightarrow 短整数$：==高位截断，保留低位==（$0\times 000286a1\Rightarrow 0\times 86a1$）

$短整数\Rightarrow 长整数$：==符号扩展（符号位补1）==（$1110\ 1111\ 0001\ 1111\Rightarrow 1111\ 1111\ 1111\ 1111\ 1110\ 1111\ 0001\ 1111$）

`大小端`

<img src="组成原理.assets/截屏2022-12-13 14.57.59.png" alt="截屏2022-12-13 14.57.59" style="zoom:50%;" />

`浮点数`

<img src="组成原理.assets/截屏2022-11-21 16.49.52.png" alt="截屏2022-11-21 16.49.52" style="zoom:50%;" />

**阶码**：常用<u>补码或移码</u>表示的定点整数；阶码E反映浮点数的表示范围及小数点的实际位置

​			（阶码为正，相当于算术左移一位；阶码为负，相当于算术右移一位）

**尾数**：常用<u>原码或补码</u>表示的定点小数；尾数M的数值部分的位数n反映浮点数的精度

**浮点数的真值**：$N=r^E\times M（r为阶码的底，通常取2）$

<img src="组成原理.assets/截屏2022-11-21 17.03.14.png" alt="截屏2022-11-21 17.03.14" style="zoom:30%;" />



<img src="组成原理.assets/截屏2022-12-13 15.18.23.png" alt="截屏2022-12-13 15.18.23" style="zoom:50%;" />



<img src="组成原理.assets/截屏2022-12-13 16.22.20.png" alt="截屏2022-12-13 16.22.20" style="zoom:50%;" />



<img src="组成原理.assets/截屏2022-12-13 16.40.38.png" alt="截屏2022-12-13 16.40.38" style="zoom:50%;" />



<img src="组成原理.assets/截屏2022-12-13 16.39.29.png" alt="截屏2022-12-13 16.39.29" style="zoom:50%;" />

<img src="组成原理.assets/截屏2022-12-13 16.46.55.png" alt="截屏2022-12-13 16.46.55" style="zoom:50%;" />

### 第3章 存储系统

$K:2^{10}、M:2^{20}、G:2^{30}、T:2^{40}$；$1ms=1\times 10^{-3}s、1us=1\times 10^{-6}s；1ns=1\times 10^{-9}s$

`存储器的层次化结构`

**主存—辅存**：==解决了主存容量不够的问题==						**Cache—主存**：==解决了主存和CPU速度不匹配的问题==

主存和Cache之间的数据调动是由==硬件==自动完成的，对==所有程序员是透明的==

主存和辅存之间的数据调动是由==硬件和操作系统==共同完成的，对==应用程序员是透明的==

计算机的存储器采用分级方式是**为了解决容量、速度、价格三者之间的矛盾**

==计算机的存储系统包括CPU内部寄存器、Cache、主存和外存==

`存储器的分类`

**按存储介质分类**

<u>磁表面存储器</u>（磁盘、磁带）、<u>半导体存储器</u>（主存、Cache）、<u>光存储器</u>（光盘）

**按存取方式分类**

* **随机存储器（RAM）**

	存取时间与存储单元的物理位置==无关==

* **只读存储器（ROM）**

	存储器的内容只能随机读出而不能写入		==ROM和RAM均为随机存取且均是半导体存储器==

* **串行访问存储器**

	（读写某个存储单元所需时间与存储单元的物理位置有关）

	* **顺序存取存储器（SAM）**

		读写一个存储单元所需时间==取决于存储单元所在的物理位置==（磁带）；==存取速度慢==

	* **直接存取存储器（DAM）**

		先<u>直接选取信息所在区域，然后按顺序方式存取</u>（磁盘、光盘）；==既有随机存取特性，也有顺序存取特性==

* **相联存储器**

	可以按==内容或地址==检索到存储位置进行读写（快表）

| 顺序访问 | 既可顺序访问又可随机访问 |
| :------: | :----------------------: |
|   磁带   |     光盘、U盘、磁盘      |

**按信息的可保存性**

* **易失性存储器**				 断电后，存储信息即**消失**（RAM）

* **非易失性存储器**			断电后，存储信息**依然保持**（ROM）
* **破坏性读出**				     信息读出后，原存储信息**被破坏**
* **非破坏性读出**              信息读出后，原存储信息**不被破坏**

`存储器的性能指标`

**存储容量**：==存储容量 = 存储字数 X 字长==（如8Kx8位，即$2^{13}\times 8bit$）

**单位成本**：==$每位价格 = \frac{总成本}{总容量}$==

**存储速度**：==$数据传输率（主存带宽） = \frac{数据的宽度（存储字长）}{存储周期}$==

**存取时间**：指从启动一次存储器操作到完成该操作所经历的时间

**存取周期**：连续两次独立访问存储器操作之间所需的最小时间间隔

<img src="组成原理.assets/截屏2022-06-28 21.16.34.png" alt="截屏2022-06-28 21.16.34" style="zoom: 60%;" />

`主存储器的基本组成`

<img src="组成原理.assets/截屏2022-08-18 17.44.29.png" alt="截屏2022-08-18 17.44.29" style="zoom:60%;" />

**主存储器的基本构成**

<img src="组成原理.assets/截屏2022-08-18 18.01.32.png" alt="截屏2022-08-18 18.01.32" style="zoom:60%;" />

`半导体随机存储器`

==SRAM、DRAM都属于易失性存储器==

 **DRAM**

==用于主存==（**现在的主存通常采用SDRAM**，SDRAM也需要周期性刷新）

存储元使用==栅极电容==存储信息，==破坏性读出==，读出后需要重写信息

==分两次送行列地址==（地址线复用技术，**导致地址线、地址引脚减半**）

**优点**：==容易集成、成本低、集成度高、功耗低==					**缺点**：==存取速度比SRAM慢==（由于读出后需要重写）

**芯片引脚数**：（1024x8位）

==$数据线=数据位数=8；行列选通线：2（片选线用行列选通线代替）；读/写控制线：1或2$==

==$地址线=[log_2(寻址范围)]/2=[log_2(1024)]/2=5；$==

**刷新**：（**刷新周期为2ms，每次刷新一行存储单元**（==刷新以行为单位==））

<u>“刷新”由存储器独立完成，不需要CPU控制</u>；<u>采用行列地址是为了减少选通线的数量</u>

==一次完整的刷新过程占用一个存储周期==

* **集中刷新**

	在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作（称为<u>死时间、访存死区</u>）

* **分散刷新**

  把对每行的刷新分散到各个工作周期中，一个存储器的系统工作周期分为两部分，前半部分用于正常读写，后半部分用于刷新

  ==不存在死时间==

* **异步刷新**

  将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求

  **既可缩短“死时间”，又能充分利用最大刷新间隔为2ms的特点**

**SRAM**

==用于Cache==、存储元使用==双稳态触发器==存储信息，==非破坏性读出==，==同时送行列地址==

**优点**：==存取速度快==												**缺点**：==成本高、集成度低、功耗大==

**芯片引脚数**：（1024x8位）

==$数据线=数据位数=8；片选线：1；读/写控制线：1或2$==

==$地址线=log_2(寻址范围)=log_2(1024)=10；(32K\times 16\Rightarrow 地址线=15)$==

`主存储器与CPU的连接`

**位扩展**

<img src="组成原理.assets/截屏2022-08-18 18.05.35.png" alt="截屏2022-08-18 18.05.35" style="zoom:50%;" />

**字扩展**

* **线选法**

	==$n条线\to n个选片信号$==、电路简单、==地址空间不连续==（有的地址不能使用）

	<img src="组成原理.assets/截屏2022-08-18 18.17.39.png" alt="截屏2022-08-18 18.17.39" style="zoom:50%;" />



* **译码片选法**

	==$n条线\to 2^n个选片信号$==、电路复杂、==地址空间连续==

	<img src="组成原理.assets/截屏2022-08-18 18.14.34.png" alt="截屏2022-08-18 18.14.34" style="zoom:50%;" />

**字位同时扩展**

<img src="组成原理.assets/截屏2022-08-18 18.24.56.png" alt="截屏2022-08-18 18.24.56" style="zoom:50%;" />

**译码器**

<img src="组成原理.assets/截屏2022-08-18 18.27.46.png" alt="截屏2022-08-18 18.27.46" style="zoom:50%;" />

`双端口RAM和多模块存储器`

**双端口RAM**

**双端口存储器具有两套独立读/写口，具有各自的地址寄存器和译码电路**

1⃣️ 两个端口同时对不同地址单元存取数据 🉑️			2⃣️ 两个端口同时对同一地址单元读出数据 🉑️

3⃣️ 两个端口同时对同一地址单元写入数据 （❌写入错误）

4⃣️ 两个端口同时对同一地址单元，一个写入数据，另一个读出数据（❌读出错误）

**解决**：置“忙”信号为0，由判断逻辑决定暂时关闭一个端口，未被关闭的端口正常访问，被关闭的端口延长一个很短的时间短				后再访问

**多体并行存储器**

<u>每个模块都有相同的容量和存取速度</u>

<u>各模块都有独立的读写控制电路、地址寄存器和数据寄存器，它们既能并行又能交叉工作</u>

* **高位交叉编址**

  ==不满足程序局部性原理==

  <img src="组成原理.assets/截屏2022-08-18 21.44.07.png" alt="截屏2022-08-18 21.44.07" style="zoom:50%;" />

* **低位交叉编址**

  ==$连续取n个存储字耗时T+(n-1)r$==（每个存储体存取周期为T，存取时间为r）

  ==$为了使流水线不间断，应保证m\ge \frac{T}{r}$==（m体交叉存储器，每个存储体存取周期为T，<u>存取时间/总线传输周期</u>为r）

  ==满足程序局部性原理==

  <img src="组成原理.assets/截屏2022-08-18 21.44.30.png" alt="截屏2022-08-18 21.44.30" style="zoom:50%;" />
  
  （$蓝色位数为log_2N$，N为芯片数）

**单体多字存储器**

（类似于字扩展法）

==每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字==（不能单独取其中某个字）

`只读存储器`

==CD-ROM是只读型光盘存储器（顺序存取），不属于只读存储器==

**掩模式只读存储器**（MROM）

厂家在生产过程直接写入，==写入以后任何人无法改变内容==

**优点**：==可靠性高，集成度高，价格便宜==				**缺点**：==灵活性差==

**一次可编程只读存储器**（PROM）

允许用户利用专门的设备写入自己的程序，==一旦写入，内容无法改变==

**可擦除可编程只读存储器**（EPROM）

允许用户写入信息，且==可多次重写==；==随机存取==

* **紫外线擦除**（UVEPROM）            需要擦除全部，然后写入

* **电擦除**（EEPROM）                      只需擦除特定的字

**闪速存储器（Flash Memory）**

（U盘、SD卡）<u>存储元由mos管组成</u>

==断电后也能保存信息，且可进行多次快速擦除重写==（读比写快，因为写入需要先擦除原有数据）

**固态硬盘**

<u>由控制单元和存储单元（Flash芯片）构成</u>			==速度快、功耗低，但价格高==

<img src="组成原理.assets/截屏2022-08-19 16.42.23.png" alt="截屏2022-08-19 16.42.23" style="zoom: 55%;" />

==静态磨损均衡算法比动态磨损均衡算法的表现更优秀==（因为在没有写入数据的时候进行的数据迁移）

`磁盘存储器`

**磁表面存储器**

<u>每次读写只能1bit</u>

**优点**： 1⃣️ ==存储容量大，位价格低== 								   2⃣️ 记录介质可以重复使用

​				 3⃣️ 记录的信息可以长期保存而不丢失	  		 4⃣️ **非破坏性读出**，读出时不需要再生

**缺点**： 1⃣️ ==存取速度慢==		2⃣️ 机械结构复杂		3⃣️ 对工作环境要求较高（容易被磁场干扰）

**磁盘设备的组成**

* **存储区域**

​			一块硬盘有若干个记录面，每个记录面划分为若干条磁道，每条磁道又划分为若干个扇区

​			==扇区（块）是磁盘读写的最小单位（磁盘按块存取）==

​			**磁头数**：即记录面数（一个记录面对应一个磁头），表示硬盘共有多少个磁头

​			**柱面数**：表示硬盘每一面盘片上有多少条磁道

​			**扇区数**：表示每一条磁道上有多少个扇区；==每一个扇区所能存储的二进制数据大小都是相同的==

* **硬盘存储器**

	 1⃣️ **磁盘驱动器**，核心部件是磁头组件和盘片组件

	 2⃣️ **磁盘控制器**，是硬盘存储器和主机的接口，主流的标准有IDE、SCSI、SATA

**磁盘的性能指标**

* **磁盘容量**

	（一个磁盘所能存储的字节总数）

	1⃣️ **非格式化容量**，指磁记录表面可以利用的磁化单元总数

	2⃣️ **格式化容量**，指按照某种特定的记录格式所能存储信息的总量；一般<u>非格式化容量 > 格式化容量</u>

* **记录密度**

	1⃣️ **道密度**，沿磁盘半径方向单位长度上的磁道数（如60道/cm）

	2⃣️ **位密度**，磁道单位长度上所能记录的二进制代码位数（如600bit/cm）

	​       ==每个磁道的位密度都不同，越内侧的磁道位密度越大==（由于**所有磁道记录的信息量是相等的**，但磁道半径不一样）

	3⃣️ **面密度**，道密度与位密度的乘积

* **平均存取时间**

	==$平均存取时间=寻道时间（磁头移动到目的磁道）+旋转延迟时间（磁头定位到所在扇区）+传输时间（传输数据所花费的时间）$==

* **数据传输率**

	（磁盘存储器在单位时间内向主机传送数据的字节数）

	==$数据传输率=rN$==（磁盘转速为r（转/秒），每条磁道容量为N个字节）

**磁盘地址**

<img src="组成原理.assets/截屏2022-08-19 16.18.13.png" alt="截屏2022-08-19 16.18.13" style="zoom:50%;" />

**硬盘的工作过程**

硬盘的主要操作是寻址、读盘、写盘；每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字；硬盘属于机械式部件，其==读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据==

**磁盘阵列**

廉价冗余磁盘阵列（RAID），是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上分割交叉存储、并行访问，具有更好的存储性能、可靠性（**编号中的数值越大可靠性越高**）和安全性

1⃣️ **RAID0**：无冗余和无校验的磁盘阵列（==没有容错能力==；类似低位交叉编址的多体存储器）

<img src="组成原理.assets/截屏2022-08-19 16.33.08.png" alt="截屏2022-08-19 16.33.08" style="zoom:45%;" />

2⃣️ **RAID1**：镜像磁盘阵列（存两份数据，==意味着容量减少一半==）

<img src="组成原理.assets/截屏2022-08-19 16.34.04.png" alt="截屏2022-08-19 16.34.04" style="zoom:45%;" />

3⃣️ **RAID2**：采用纠错的海明码的磁盘阵列

（逻辑上连续的几个bit物理上分散存储在各个盘中，4bit信息位+3bit海明校验位，可纠正一位错）

<img src="组成原理.assets/截屏2022-08-19 16.30.57.png" alt="截屏2022-08-19 16.30.57" style="zoom:40%;" />

4⃣️ **RAID3**：位交叉奇偶校验的磁盘阵列

5⃣️ **RAID4**：块交叉奇偶校验的磁盘阵列

6⃣️ **RAID5**：无独立校验的奇偶校验磁盘阵列

`Cache的概念和原理`

**“Cache—主存”系统的平均访问时间**：

<u>不同时访问</u>：==$t=Ht_c+(1-H)(t_c+t_m)$==（$H为命中率，t_c为访问一次Cache所需时间，t_m为访问一次主存所需时间$）

<u>同时访问</u>：==$t=Ht_c+(1-H)t_m$==

==主存与Cache之间以块为单位进行数据交换==

`Cache和主存的映射方式`

* **全相联映射**

  **访存过程**：（CPU访问主存地址1...1101001110）

  1⃣️ 对比Cache中所有块的标记和主存地址的前22位  2⃣️ 若标记匹配且有效位 = 1，则命中 ,访问块内地址为001110的单元

  3⃣️ 若未命中或有效位 = 0， 则正常访问主存

  <img src="组成原理.assets/截屏2022-08-19 17.15.04.png" alt="截屏2022-08-19 17.15.04" style="zoom:45%;" />

  **优点**：<u>Cache存储空间利用充分，命中率高</u>

  **缺点**：<u>查找标记最慢</u>

  **替换算法**：<u>Cache完全满了才需要替换</u>，需要在<u>全局</u>选择替换哪一块

* **直接映射**

  ==$主存块在Cache中的位置=主存块号\%Cache总块数$==

  ==$若Cache总块数=2^n，则主存块号末尾n位直接反映它在Cache中的位置（由于主存块号\%2^n相当于留下最后n位二进制数）$==

  ==因此只需主存块号的其余位作为标记即可==

  <img src="组成原理.assets/截屏2022-08-19 17.54.45.png" alt="截屏2022-08-19 17.54.45" style="zoom:45%;" />

  **访存过程**：（CPU访问主存地址01000001110 ）

  1⃣️ 根据主存块号的后3位确定Cache行

  2⃣️ 若主存块号的前19位与Cache标记匹配且有效位 = 1，则命中，访问块内地址为001110的单元

  3⃣️ 若未命中或有效位 = 0，则正常访问主存

  **优点**：<u>查找标记速度最快</u>

  **缺点**：<u>灵活性差、Cache存储空间利用不充分，命中率低</u>

  **替换算法**：<u>不需要替换算法</u>，如果对应位置非空，则毫无选择地直接替换

* **组相联映射**

	==$所属分组=主存块号\%分组数$==

	==$若Cache总组数=2^n，则主存块号末尾n位直接反映它在Cache中的组号，因此只需主存块号的其余位作为标记即可$==

	<img src="组成原理.assets/截屏2022-08-19 17.56.47.png" alt="截屏2022-08-19 17.56.47" style="zoom:45%;" />

	**访存过程**：（CPU访问主存地址1...1101001110）

	1⃣️ 根据主存块号的后2位确定所属分组号

	2⃣️ 若主存块号的前20位与分组内的某个标记匹配且有效位 = 1，则Cache命中，访问块内地址为001110的单元
	3⃣️ 若未命中或有效位 = 0，则正常访问主存

	<img src="组成原理.assets/截屏2022-08-19 18.02.18.png" alt="截屏2022-08-19 18.02.18" style="zoom:45%;" />

	**优点**：<u>另外两种方法的折中，综合效果较好</u>
	
	**替换算法**：<u>分组内满了才需要替换</u>，需要在<u>分组内</u>选择替换哪一块

`Cache替换算法`

* **随机算法**（RAND）

	（若Cache已满，则随机选择一块替换）

	==实现简单、命中率低（没考虑到局部性原理）==

* **先进先出算法**（FIFO）

	（若Cache已满，则替换最先被调入的Cache块）

	==实现简单、没考虑到局部性原理==、==会出现抖动现象==（刚被替换的块很快又被调入）

* **近期最少使用算法**（LRU）

	（为每一个Cache块设置一个计数器，用于记录每个Cache块已经多久没被访问了，当Cache满后替换计数器最大的）

	1⃣️ 未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1

	2⃣️ 命中时，所命中的行的计数器清零，比其低的计数器加1,其余不变

	3⃣️ 未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1

	==$若Cache块的总数为2^n，则计数器只需n位$==、==Cache装满后所有计数器的值一定不重复==

	<img src="组成原理.assets/截屏2022-08-20 14.52.20.png" alt="截屏2022-08-20 14.52.20" style="zoom:50%;" />

	==基于局部性原理、命中率高==、==若被频繁访问的主存块数量 > Cache行的数量，则可能发生抖动==

* **最不经常使用算法**（LFU）

	（为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后替换计数器最小的）

	新调入的块的计数器为0，之后每被访问一次计数器+1；需要替换时，选择计数器最小的一行

	（若有多个计数器最小的行，可按行号递增或FIFO策略进行选择）

	==不遵循局部性原理==（曾经被经常访问的主存块在未来不一定会用到）、==实际运行效果不如LRU==

`Cache写策略`

* **写命中**

	* **写回法**

		（当CPU对Cache写命中时，只修改Cache的内容，而不立即写入主存，只有当此块**被换出时**才写回主存）

		需要增加一位==脏位==表示是否被修改过

	* **全写法**（写直通法）

		（当CPU对Cache写命中时，必须把数据**同时写入**Cache和主存，一般使用写缓冲）

* **写不命中**

	* **写分配法**

		（当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中修改；通常**搭配写回法**使用）

	* **非写分配法**

		（当CPU对Cache写不命中时，**只写入主存，不调入Cache**；**搭配全写法使用**）

`多级Cache`

<u>离CPU越近，速度越快，容量越小；离CPU越远，速度越慢，容量越大</u>

==各级Cache之间采用全写法+非写分配法；Cache—主存之间采用写回法+写分配法==

### 第4章 指令系统

`指令分类`

* **零地址指令**

	1⃣️ 不需要操作数，如空操作、停机、关中断等指令

	2⃣️ 堆栈计算机，==两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶==

* **一地址指令**

  <img src="组成原理.assets/截屏2022-10-16 09.56.12.png" alt="截屏2022-10-16 09.56.12" style="zoom:33%;" />

  1⃣️ 只需要单操作数，如加1、减1、取反、求补等（完成一条指令需要3次访存：取指→读A1→写A1）

  2⃣️ 需要两个操作数，但其中一个操作数隐含在某个寄存器（完成一条指令需要2次访存：取指→读A1）

  （即<u>单地址指令可能有一个操作数，也可能有两个操作数</u>）

* **二地址指令**

	<img src="组成原理.assets/截屏2022-10-16 10.00.02.png" alt="截屏2022-10-16 10.00.02" style="zoom:33%;" />

	常用于需要两个操作数的算术运算、逻辑运算相关指令（完成一条指令需要访存4次：取指→读A1→读A2 >写A1）

* **三地址指令**

	<img src="组成原理.assets/截屏2022-10-16 10.00.27.png" alt="截屏2022-10-16 10.00.27" style="zoom:33%;" />

	常用于需要三个操作数的算术运算、逻辑运算相关指令（完成一条指令需要访存4次：取指→读A1→读A2→写A3）

* **四地址指令**

	<img src="组成原理.assets/截屏2022-10-16 10.03.11.png" alt="截屏2022-10-16 10.03.11" style="zoom:33%;" />

	正常情况下：取指令之后PC+1，指向下一条指令；而四地址指令：==执行指令后，将PC的值修改为A4所指地址==

	完成一条指令需要访存4次：取指→读A1→读A2→写A3

`扩展操作码`

**定长操作码**

（在指令字的最高位部分分配固定的若干位表示操作码）

**优点**：定长操作码对于简化计算机硬件设计，<u>提高指令译码和识别速度很有利</u>

**缺点**：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限

**不定长操作码**

（全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上）
**优点**：在指令字长有限的前提下仍保持比较丰富的指令种类          **缺点**：<u>增加了指令译码和分析的难度，使控制器的设计复杂化</u>

<img src="组成原理.assets/截屏2022-10-16 10.12.06.png" alt="截屏2022-10-16 10.12.06" style="zoom:33%;" />

**采用扩展操作码的目的**：==保持指令字长度不变而增加指令的数量==

**设计扩展操作码原则**

1⃣️ 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同    2⃣️ 各指令的操作码一定不能重复

==$设地址长度为n，上一层留出m种状态，下一层可扩展出m\times 2^n种状态$==

`指令寻址`

（确定下一条欲执行指令的指令地址）

* **顺序寻址**

	对于定长指令字结构且主存按字编址：每次取指令结束后，$(PC)+1\to PC$

	对于变长指令字结构且主存按字编址：每次取指令结束后，根据操作码判断这条指令的总字节数n，$(PC)+n\to PC$

* **跳跃寻址**

	每次取指令结束后，$(PC)+1\to PC$，读指令发现是转移指令（JMP、CALL），将PC中的值修改为指令中的地址码

`数据寻址`

（确定本条指令的地址码指明的真实地址）

**采用不同寻址方式的目的**：==为了缩短指令字长，扩大寻址空间，提高编程的灵活性==；但这也==提高了指令译码的复杂度==

<u>程序控制是靠转移指令而非寻址方式实现的</u>

* **立即寻址**

	（形式地址A就是操作数本身，又称为立即数，一般采用补码形式）

	==一次访存==（仅当取指令时；执行指令不需要访存）

	**优点**：指令执行阶段不访问主存，指令执行时间最短     **缺点**：A的位数限制了立即数的范围

* **直接寻址**

	（指令字中的形式地址A就是操作数的真实地址）

	==两次访存==（取指令、执行指令各一次）

	**优点**：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址

	**缺点**：A的位数决定了该指令操作数的寻址范围（寻址范围小）；==操作数的地址不易修改==

	<img src="组成原理.assets/截屏2022-10-16 11.44.43.png" alt="截屏2022-10-16 11.44.43" style="zoom:25%;" />

* **间接寻址**

	（指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址）

	**优点**：==可扩大寻址范围==；便于编制程序（用间接寻址可以方便地完成子程序返回）

	**缺点**：指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）

	<img src="组成原理.assets/截屏2022-10-16 11.47.27.png" alt="截屏2022-10-16 11.47.27" style="zoom:25%;" />

* **寄存器寻址**

	（在指令字中直接给出操作数所在的寄存器编号，其操作数在所指的寄存器内）

	==一次访存==（仅当取指令时；执行指令不需要访存）

	**优点**：指令在执行阶段不访问主存，只访问寄存器；指令字短且执行速度快；支持向量/矩阵运算

	**缺点**：寄存器价格昂贵

	<img src="组成原理.assets/截屏2022-10-16 11.53.19.png" alt="截屏2022-10-16 11.53.19" style="zoom:28%;" />

* **寄存器间接寻址**

	（寄存器中给出的不是一个操作数，而是操作数所在主存单元的地址）

	==两次访存==（取指令、执行指令各一次）；比一般间接寻址相比速度更快

	<img src="组成原理.assets/截屏2022-10-16 11.57.50.png" alt="截屏2022-10-16 11.57.50" style="zoom:30%;" />

* **隐含寻址**

	（不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址）

	**优点**：有利于缩短指令字长       **缺点**：需增加存储操作数或隐含地址的硬件

	<img src="组成原理.assets/截屏2022-10-16 12.00.02.png" alt="截屏2022-10-16 12.00.02" style="zoom:28%;" />

* **偏移寻址**

	*  **基址寻址**

		（将CPU中基址<u>寄存器BR的内容（不可变）</u>加上指令格式中的<u>形式地址A（可变）</u>，而形成操作数的有效地址）

		<u>基址寄存器</u>是面向操作系统的，其==内容由操作系统或管理程序确定==

		当<u>采用通用寄存器作为基址寄存器</u>时，可由用户决定哪个寄存器作为基址寄存器，但其==内容仍由操作系统确定==

		**优点**：可扩大寻址范围；==便于程序“浮动”==（整段程序在内存里的浮动）；==方便实现多道程序并发运行==

		<img src="组成原理.assets/截屏2022-10-16 12.08.14.png" alt="截屏2022-10-16 12.08.14" style="zoom:33%;" />

	* **变址寻址**

		（有效地址EA等于<u>变址寄存器IX的内容（可变）</u>与指令字中的<u>形式地址A（不可变）</u>相加之和）

		==IX可为变址寄存器，也可用通用寄存器作为变址寄存器==；==适合编制循环程序==（结合数组）

		变址寄存器是面向用户的，在程序执行过程中，==变址寄存器的内容可由用户改变==

		<img src="组成原理.assets/截屏2022-10-16 12.16.43.png" alt="截屏2022-10-16 12.16.43" style="zoom:28%;" />
		
	* **相对寻址**
	
	  把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，A是相对于PC所指地址（下一条指令地址）的位移量，可正可负，补码表示
	
	  ==便于程序浮动==（一段代码在程序内部的浮动）；==广泛应用于转移指令==
	
	  <img src="组成原理.assets/截屏2022-10-16 16.54.51.png" alt="截屏2022-10-16 16.54.51" style="zoom: 30%;" />
	
* **堆栈寻址**

  （操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址）

  **硬堆栈**：由寄存器组成的堆栈          **软堆栈**：在内存中划分出来的堆栈

  **入栈**：$有效地址 = (SP)$          **出栈**：$有效地址 = (SP) \pm 1$

  **访存次数**：==硬堆栈，指令执行时不访存；软堆栈，指令执行时访存一次==

  <img src="组成原理.assets/截屏2022-10-16 17.11.49.png" alt="截屏2022-10-16 17.11.49" style="zoom:28%;" />
  
  ​    <img src="组成原理.assets/截屏2022-10-16 17.10.44.png" alt="截屏2022-10-16 17.10.44" style="zoom:28%"/>

`汇编指令`

<img src="组成原理.assets/截屏2022-11-29 15.20.35.png" alt="截屏2022-11-29 15.20.35" style="zoom:33%;" />

<img src="组成原理.assets/截屏2022-11-29 15.23.26.png" alt="截屏2022-11-29 15.23.26" style="zoom:33%;" />

<img src="组成原理.assets/截屏2022-11-29 15.35.16.png" alt="截屏2022-11-29 15.35.16" style="zoom:33%;" />

`CISC和RISC`

**CISC**：一条指令完成一个复杂的基本功能；代表：x86架构，主要用于笔记本、台式机

**RISC**：一条指令完成一个基本动作，多条指令组合完一个复杂的基本功能；代表：ARM架构，主要用于手机、平板

<img src="组成原理.assets/截屏2022-10-14 10.02.09.png" alt="截屏2022-10-14 10.02.09" style="zoom:33%;" />

==相比CISC，RISC的指令格式和寻址种类较少==

### 第5章 中央处理器

`CPU的功能和基本结构`

**CPU的功能**

1️⃣ **指令控制**，完成取指令、分析指令和执行指令的操作，即程序的顺序控制

2️⃣ **操作控制**，一条指令的功能往往是由若干操作信号的组合来实现的；CPU管理并产生由内存取出的每条指令的操作信号，

​		把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作

3️⃣ **时间控制**，对各种操作加以时间上的控制；时间控制要为每条指令按时间顺序提供应有的控制信号

4️⃣ **数据加工**，对数据进行算术和逻辑运算

5️⃣ **中断处理**，对计算机运行过程中出现的异常情况和特殊请求进行处理

**CPU的基本机构**

* **运算器**

	**组成**：1️⃣ **算术逻辑单元**（ALU）：主要功能是进行算术/逻辑运算

	​				2️⃣ **通用寄存器组**：如AX、BX、 CX、DX、SP，用于存放操作数和各种地址信息

	​				3️⃣ **暂存寄存器**：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容

	​					（配合CPU内部单总线方式）

	​				4️⃣ **累加寄存器**（ACC）：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算

	​				5️⃣ **程序状态字寄存器**：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，

	​						PSW中的这些位参与并决定微操作的形成

	​				6️⃣ **移位器**：对运算结果进行移位运算				7️⃣ **计数器**（CT）：控制乘除运算的操作步数

* **控制器**

	（协调并控制计算机各部件执行程序的指令序列，**基本功能包括取指令、分析指令、执行指令**）

	**取指令**：自动形成指令地址；自动发出取指令的命令

	**分析指令**：操作码译码（分析本条指令要完成什么操作）；产生操作数的有效地址

	**执行指令**：根据分析指令得到的操作命令和操作数地址形成操作信号控制序列，控制运算器、存储器及I/O设备完成相应的操作

	**组成**：1️⃣ **程序计数器**（PC）：用于指出下一条指令在主存中的存放地址

	​				2️⃣ **指令寄存器**（IR）：用于保存当前正在执行的那条指令

	​				3️⃣ **指令译码器**：仅对操作码字段进行译码，向控制器提供特定的操作信号

	​				4️⃣ **微操作信号发生器**：根据IR的内容、PSW的内容及时序信号，产生控制整个计算机系统所需的

	​						各种控制信号，其结构有组合逻辑型和存储逻辑型两种

	​				5️⃣ **时序系统**：用于产生各种时序信号，它们都是由统一时钟(CLOCK) 分频得到

	​				6️⃣ **存储器地址寄存器**（MAR）：用于存放所要访问的主存单元的地址

	​				7️⃣ **存储器数据寄存器**（MDR）：用于存放向主存写入的信息或从主存中读出的信息

`指令周期`

**指令周期**：CPU从内存<u>取出一条指令并执行这条指令</u>的时间总和，==通常用若干机器周期来表示==

**中断周期**：执行一次中断所需要的周期

**CPU周期**：又称<u>机器周期</u>，从内存取一条指令的最短时间，==包含若干个时钟周期==

==不同指令的指令周期可能不同，每个指令周期内机器周期数可以不等，每个机器周期内的节拍数也可以不等==

<center class="half">
<img src="组成原理.assets/截屏2022-09-03 14.45.52.png" alt="截屏2022-09-03 14.45.52" style="zoom:65%;" />
    <img src="组成原理.assets/截屏2022-09-04 16.40.28.png" alt="截屏2022-09-04 16.40.28" style="zoom:55%;margin-left:50px" />
</center>



==对于间接寻址的指令，需要包括间址周期==（取操作数需要先访问一次主存取出有效地址，然后访问主存，取操作数）

==四个工作周期都有CPU访存操作==，只是访存的目的不同：

**取指周期**是为了<u>取指令</u>；**间址周期**是为了<u>取有效地址</u>；**执行周期**是为了<u>取操作数</u>；**中断周期**是为了<u>保存程序断点</u>

==为了区别不同的工作周期，在CPU内分别设置了4个标志触发器==FE、IND、EX、INT，状态为1表示有效

**数据流向**

* **取指周期**

	1️⃣ 当前指令地址送至存储器地址寄存器，(PC) —> MAR

	2️⃣ CU发出控制信号，经控制总线传到主存，这里是读信号，1—> R

	3️⃣ 将MAR所指主存中的内容经数据总线送入MDR，M(MAR) —> MDR

	4️⃣ 将MDR中的内容送入IR，(MDR)> IR         5️⃣ CU发出控制信号，形成下一条指令地址，(PC) + 1 →PC

* **间址周期**

	1️⃣ 将指令的地址码送入MAR，Ad(IR) —> MAR 或 Ad(MDR) —> MAR

	2️⃣ CU发出控制信号，启动主存做读操作，1—> R

	3️⃣ 将MAR所指主存中的内容经数据总线送入MDR，M(MAR) —> MDR

	​		或将有效地址送至指令的地址码字段（替换掉原指令的地址码）， (MDR)→ Ad(IR)

* **执行周期**

	不同指令的执行周期操作不同，没有统一的数据流向

* **中断周期**

	1️⃣ CU控制将SP减1，修改后的地址送入MAR，(SP) - 1→SP，(SP) —> MAR

	​		（减1是因为内存中的堆栈是反过来的，高地址在上，低地址在下）

	​		本质上是将断点存入某个存储单元，假设其地址为a，故a —> MAR

	2️⃣ CU发出控制信号，启动主存做写操作，1—>W           3️⃣ 将断点(PC内容)送入MDR， (PC) —> MDR

	4️⃣ CU控制将中断服务程序的入口地址(由向量地址形成部件产生)送入PC，向量地址 —> PC

**指令执行方案**

* **单指令周期**

	（对所有指令都选用<u>相同的执行时间</u>来完成）

	指令之间==串行==执行（即下一条指令只能在前一条指令执行结束后才能启动）

	==指令周期取决于执行时间最长的指令的执行时间==

	**缺点**：==会降低整个系统的运行速度==（对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成）

* **多指令周期**

	（对不同类型的指令选用不同的执行步骤来完成）
	指令之间==串行==执行；可选用不同个数的时钟周期来完成不同指令的执行过程，<u>指令需要几个周期就分配几个</u>

	**缺点**：需要更复杂的硬件设计

* **流水线方案**

	（在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中）

	指令之间==并行==执行

`数据通路`

**数据通路的基本结构**

* **专用数据通路方式**

  （根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，即每个寄存器有多条线连接目标器件）

  **优点**：==性能较高，基本不存在数据冲突现象==				**缺点**：==结构复杂，硬件量大， 不易实现==

  > 如果直接用导线连接，相当于多个寄存器同时并且一直向ALU传输数据
  >
  > **解决方法1**：使用多路选择器，根据控制信号选择一路输出
  >
  > **解决方法2**：使用三态门可以控制每一路是否输出
  >
  > ​							（如R0out为1时 R中的数据输出到A端；R0out为0时，R中的数据无法输出到A端）

  <img src="组成原理.assets/截屏2022-09-03 14.04.17.png" alt="截屏2022-09-03 14.04.17" style="zoom:50%;" />

  **取指过程**：

  <img src="组成原理.assets/截屏2022-09-08 16.57.53.png" alt="截屏2022-09-08 16.57.53" style="zoom:50%;" />

* **CPU内部单总线方式**

	（将所有寄存器的输入端和输出端都连接到一条公共的通路上）

	**优点**：==结构简单，容易实现==					**缺点**：==数据传输存在较多冲突的现象，性能较低==

	* **寄存器之间的数据传送**
	
		（把PC内容送至MAR）
	
		 (PC) —> Bus —> MAR            PCout有效，PC内容送总线；MARin有效，总线内容送MAR
	
	* **主存与CPU之间的数据传送**
	
		（CPU从主存读取指令）
	
		 (PC) —> Bus —>MAR             PCout和MARin有效，下一条指令地址 —> MAR
	
		 1 —> R                                   CU发读命令（通过控制总线发出）
	
		 MEM(MAR) —> MDR              MDRin有效
	
		 MDR —> Bus —> IR                 MDRout和IRin有效，下一条指令 —> IR
	
	* **执行算术或逻辑运算**
	
		（一条加法指令）
	
		 Ad(IR) —> Bus —> MAR                      MDRout和MARin有效
	
		 1 —> R                                                 CU发读命令
	
		 MEM(MAR) —> 数据线 —> MDR         MDRin有效
	
		 MDR —> Bus —> Y                               MDRout和Yin有效，操作数 —> Y，Y为暂存寄存器
	
		 (ACC)+(Y) —> Z                                     ACCout和ALUin有效，CU向ALU发送加命令，ACC存放指令携带的另一操作数
	
		 Z —> ACC                                              Zout和ACCin有效，结果 —> ACC 
	
	<img src="组成原理.assets/截屏2022-09-03 14.13.45.png" alt="截屏2022-09-03 14.13.45" style="zoom:50%;" />
	

`硬布线控制器`

<img src="组成原理.assets/截屏2022-09-08 17.23.03.png" alt="截屏2022-09-08 17.23.03" style="zoom:50%;" />

`指令流水线`

<img src="组成原理.assets/截屏2022-12-11 14.27.27.png" alt="截屏2022-12-11 14.27.27" style="zoom:50%;" />

<img src="组成原理.assets/截屏2022-12-11 14.31.41.png" alt="截屏2022-12-11 14.31.41" style="zoom:50%;" />

<img src="组成原理.assets/截屏2022-12-11 14.32.57.png" alt="截屏2022-12-11 14.32.57" style="zoom:50%;" />

<img src="组成原理.assets/截屏2022-12-11 14.36.30.png" alt="截屏2022-12-11 14.36.30" style="zoom:50%;" />

### 第6章 总线

`概述`

<img src="组成原理.assets/截屏2022-11-04 14.37.14.png" alt="截屏2022-11-04 14.37.14" style="zoom:15%;" />

==同一时刻只能有一个部件发送数据，但是可有多个部件接受数据==；==使用总线结构便于增减外设，同时减少信息传输线的条数==

<u>主存通过总线的类型来识别信息是地址还是数据，CPU通过控制单元（CU）来识别信息是地址还是数据</u>

在现代微机主板上，采用局部总线技术的作用是<u>节省系统的总带宽</u>

只有主设备才能获得总线控制权，总线上的信息传输由主设备启动，一条总线上可以有多个设备作为主设备，但在同一时刻只能有一个主设备控制总线的传输操作

**总线的分类**

* **按数据传输格式**                 1⃣️ 串行总线<u>（USB）</u>  2⃣️ 并行总线<u>（PCI、EISA、ISA）</u>

* **按总线功能**

	* **片内总线**

		片内总线是芯片内部的总线，它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线

	* **系统总线**

		系统总线是计算机系统内各功能部件（CPU、 主存、I/O接口）之间相互连接的总线

		数据总线：传输各功能部件之间的数据信息，包括指令和操作数；根数与机器字长、存储字长有关；==双向传输==

		地址总线：传输地址信息，包括==主存单元或I/O端口的地址==；根数与主存地址空间大小及设备数量有关；==单向传输==

		控制总线：传输控制信息，一根控制线传输一个信号；<u>有出（CPU送出的控制命令），有入（主存或外设返回CPU的反馈信号）</u>，即==双向传输==

	* **通信总线**（外部总线）

		用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线

**系统总线的结构**

* **单总线结构**

	 CPU、主存、I/O设备（通过I/O接口）都连接在<u>一组</u>总线上，允许I/O设备之间、I/O设备和CPU之间或I/O设备与主存之间直接交换信息

	**优点**：结构简单，成本低，易于接入新的设备

	**缺点**：带宽低、负载重，多个部件只能争用唯一的总线，且==不支持并行传送操作==

	<img src="组成原理.assets/截屏2022-11-04 14.57.35.png" alt="截屏2022-11-04 14.57.35" style="zoom:28%;" />

	（单总线并不是指只有一根信号线，系统总线按传送信息的不同可以细分为地址总线、数据总线和控制总线）

* **双总线结构**

	双总线结构有两条总线，一条是<u>主存总线</u>，用于CPU、主存和通道之间进行数据传送；另一条是<u>I/O总线</u>，用于多个外部设备与通道之间进行数据传送

	**优点**：将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线分离       **缺点**：需要增加通道等硬件设备

	<img src="组成原理.assets/截屏2022-11-04 15.05.10.png" alt="截屏2022-11-04 15.05.10" style="zoom:25%;" />

* **三总线结构**

	三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为==主存总线、I/O总线和DMA总线==

	**优点**：提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量               **缺点**：系统工作效率较低

	支持突发传输方式（一次总线事务中，主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据）

	<img src="组成原理.assets/截屏2022-11-04 15.09.16.png" alt="截屏2022-11-04 15.09.16" style="zoom:25%;" />

`总线的性能指标`

* **传输周期**（总线周期）

	一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段），通常<u>由若干个总线时钟周期构成</u>

* **工作频率**

	总线上各种操作的频率，为总线周期的倒数；实际上指一秒内传送几次数据

	==$若总线周期 = N个时钟周期（传送一个字需要N个时钟周期），则总线的工作频率 = \frac{时钟频率}{N}$==

* **时钟周期**

	即机器的时钟周期；计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制

* **时钟频率**

	即机器的时钟频率，为时钟周期的倒数；若时钟周期为T，则时钟频率为1/T；实际上指一秒内有多少个时钟周期

* **总线宽度**（总线位宽）

	总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位总线

* **总线带宽**

	可理解为<u>总线的数据传输率</u>，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单
	位可用字节/秒(B/s)表示

	==$总线带宽=总线工作频率\times 总线宽度（bit/s）=\frac{总线宽度}{总线周期}（bit/s）$==

	==$总线带宽=总线工作频率\times （总线宽度/8）（B/s）=\frac{总线宽度/8}{总线周期}（B/s）$==

* **总线复用**

	指<u>一种信号线在不同的时间传输不同的信息</u>；可以使用较少的线传输更多的信息，从而节省了空间和成本

* **信号线数**

	地址总线、数据总线和控制总线3种总线数的总和称为信号线数

`总线操纵和定时`

**总线周期的四个阶段**

1⃣️ 申请分配阶段：由需要使用总线的主模块(或主设备)提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者，也可将此阶段细分为传输请求和总线仲裁两个阶段

2⃣️ 寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块

3⃣️ 传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送

4⃣️ 结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权

**总线定时**

（指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议或规则）

* **同步通信**（同步定时方式）

	（由==统一时钟控制数据传送==；若干个时钟产生<u>相等的时间间隔</u>，每个间隔构成一个总线周期；在一个总线周期中，发送方和接收方可进行一次数据传送；==总线周期长度固定==）

	1⃣️ CPU在T1时刻的上升沿给出地址信息

	2⃣️ 在T2的上升沿给出读命令(低电平有效)，与地址信息相符合的输入设备按命令进行-系列的内部操作，且必须在T3的上升沿来之前将CPU所需的数据送到数据总线上

	3⃣️ CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中

	4⃣️ CPU在T4的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动

	<img src="组成原理.assets/截屏2022-11-05 15.01.55.png" alt="截屏2022-11-05 15.01.55" style="zoom:30%;" />

	**优点**：传送速度快，具有较高的传输速率；总线控制逻辑简单

	**缺点**：主从设备属于强制性同步，不能及时进行数据通信的有效性检验，==可靠性较差==

	同步通信适用于==总线长度较短及总线所接部件的存取时间比较接近（即速度相近）==的系统

* **异步通信**（异步定时方式）

  （采用应答方式，没有公共时钟标准，即==不采用时钟信号，只采用握手信号，每次握手的过程完成一次通信==；主设备提出交换信息的请求信号，经接口传送到从设备，从设备接到主设备的请求后，通过接口向主设备发出回答信号）

  **根据 “请求”和“回答” 信号的撤销是否互锁，分为以下3种类型：**

  * **不互锁方式**

  	主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号

  	从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号；双方不存在互锁关系

  	==速度最快，可靠性最差==

  * **半互锁方式**

  	主设备发出“请求”信号后，必须等待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系

  	从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动
  	撤销“回答”信号，不存在互锁关系

  * **全互锁方式**

  	主设备发出“请求”信号后，必须等待从设备“回答”后，才撤销“请求”信号

  	从设备发出“回答”信号，必须等待获知主设备“请求”信号已撤销后，再撤销其“回答”信号；双方存在互锁关系

  	==速度最慢，可靠性最好==

  **优点**：==总线周期长度可变==，<u>能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换</u>，自动适应时间的配合

  **缺点**：比同步控制方式稍复杂一些，==速度比同步定时方式慢==

  适用于==速度相差很大==的两个设备

  <img src="组成原理.assets/截屏2022-11-07 14.52.56.png" alt="截屏2022-11-07 14.52.56" style="zoom:33%;" />

* **半同步通信**：同步、异步结合

* **分离式通信**：充分挖掘系统总线每瞬间的潜力

<u>在不同速度的设备之间传送数据，可以选用同步控制方式，也可选用异步控制方式</u>

### 第7章 输入/输出系统

`I/O系统`

* **I/O硬件**

	包括外部设备、IO接口、I/O总线等

* **I/O软件**

	**指令**

	（通常采用I/O指令和通道指令实现主机和I/O设备的信息交换）

	* **I/O指令**

		（CPU执行的指令，用于控制I/O接口或控制通道）

		**指令格式**：1⃣️ **操作码**，识别I/O指令		2⃣️ **命令码**，做什么操作		3⃣️ **设备码**，对哪个设备进行操作

	* **通道指令**

		（通道执行的指令；==通道程序提前编制好放在主存中==）

		在含有通道的计算机中，CPU执行I/O指令对通道发出命令，由通道执行一系列通道指令，代替CPU对I/O设备进行管理

`外部设备`

**显示器**

**灰度级**：指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚

​					逼真，典型的有8位( 256级)、、16位等； n位可以表示$2^n$种不同的亮度或颜色

**显示存储器**（VRAM）：也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中；其存储

​					容量由图像分辨率和灰度级决定，分辨率越高，灰度级越多，刷新存储器容量越大

​					==$VRAM容量 = 分辨率 \times 灰度级位数；VRAM带宽 = 分辨率\times灰度级位数\times帧频$==

`I/O接口`

**作用**：1⃣️ **数据缓冲**，通过数据缓冲寄存器(DBR)达到主机和外设工作速度的匹配

​				2⃣️ **错误或状态监测**，通过状态寄存器反馈设备的各种错误、状态信息，供CPU查用

​				3⃣️ **控制和定时**，接收从控制总线发来的控制信号、时钟信号

​				4⃣️ **数据格式转换**，串-并、并-串等格式转换		5⃣️ **与主机和设备通信**，实现主机—I/O接口—I/O设备之间的通信

**组成**

**内部接口**：（对应主机侧）内部接口与系统总线相连，实质上是与内存、CPU相连

​							<del>数据的传输方式只能是并行传输</del>（既正确也不正确）

**外部接口**：（对应设备侧）外部接口通过接口电缆与外设相连，外部接口的数据传输可能是串行方式，

​							因此I/O接口需具有串/并转换功能

**工作原理**：1⃣️ **发命令**：发送<u>命令字（控制字）</u>到I/O控制寄存器，向设备发送命令（需要驱动程序的协助）

​						 2⃣️ **读状态**：从状态寄存器读取<u>状态字</u>，获得设备或I/O控制器的状态信息

​						 3⃣️ **读/写数据**：从数据缓冲寄存器发送或读取数据，完成主机与外设的数据交换

**I/O端口**：I/O控制器中的各种寄存器						**数据线作用**：读写数据、状态字、命令字（控制字）、中断类型号					

**地址线作用**：指明I/O端口										 	**控制线作用**：读/写IO端口的信号、中断请求信号

<img src="组成原理.assets/截屏2022-09-20 17.30.14.png" alt="截屏2022-09-20 17.30.14" style="zoom:38%;" />

**分类**：

* **按数据传送方式**                                    并行接口、串行接口
* **按主机访问I/O设备的控制方式**          程序查询接口、中断接口、DMA接口
* **按功能选择的灵活性**                           可编程接口、不可编程接口

`中断`

**非屏蔽中断**：关中断时也会被响应（如掉电）					**可屏蔽中断**：关中断时不会被响应

**关中断**：为了实现原子操作；==根据PSW中的IF（interrupt flag）标志位==判断是否处于关中断状态

**中断请求标记**：

为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTR，当其状态为“1”时，表示中断源有请求；这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中

<img src="组成原理.assets/截屏2022-09-21 17.34.45.png" alt="截屏2022-09-21 17.34.45" style="zoom:35%;" />

**过程**：1⃣️ **中断请求**，中断源向CPU发送中断请求信号				2⃣️ **中断响应**，判断响应中断的条件（如是否关中断）

​				3⃣️ **中断判优**，多个中断源同时提出请求时通过中断判断优先级逻辑响应一个中断源

​						**优先级**：硬件故障中断属于最高级，其次是软件中断；非屏蔽中断优于可屏蔽中断

​											 DMA请求优于I/O设备传送的中断请求；高速设备优于低速设备

​											 输入设备优于输出设备；实时设备优于普通设备

​						<u>中断判优既可以用硬件实现，也可用软件实现</u>；

​						硬件实现是通过<u>硬件排队器</u>实现的，它既可设置在CPU中，也可分散在各个中断源中；软件实现是通过<u>查询程序</u>实现

<img src="组成原理.assets/截屏2022-09-21 17.37.02.png" alt="截屏2022-09-21 17.37.02" style="zoom:50%;" />

​				4⃣️ **中断处理**，中断隐指令、中断服务程序

​						**中断隐指令**： 1⃣️ **关中断**，为了保护中断现场期间不被新的中断所打断				2⃣️ **保存断点**，保存原程序PC的值

​														3⃣️ **引出中断服务程序**，取出中断服务程序的入口地址（向量地址）并传送给PC

​														如何获取向量地址：软件查询法、硬件向量法（由<u>硬件产生向量地址</u>再由向量地址找到入口地址）

​						**中断服务程序**：1⃣️ **保护现场**，保存通用寄存器和状态寄存器的内容	2⃣️ **中断服务**（设备服务），执行中断处理

​															3⃣️ **恢复现场**，通过出栈指令或取数指令把之前保存的信息送回寄存器中

​															4⃣️ **中断返回**，通过中断返回指令回到原程序断点处

**多重中断**

**单重中断**：执行中断服务程序时不响应新的中断请求			**多重中断**：又称中断嵌套， 执行中断服务程序时可响应新的中断请求

**中断屏蔽技术**：每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个<u>屏蔽字寄存器</u>，屏蔽字寄存器的内容称为<u>屏蔽字</u>

中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，须满足下列条件：

1⃣️ 在中断服务程序中提前设置开中断指令			2⃣️ 优先级别高的中断源有权中断优先级别低的中断源

**屏蔽字设置的规律**：

1⃣️ 一般用'1'表示屏蔽，'0'表示正常申请；

2⃣️ 每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）

3⃣️ 屏蔽字中'1'越多，优先级越高；每个屏蔽字中至少有一个'1'（至少要能屏蔽自身的中断）

<center class="half">
    <img src="组成原理.assets/截屏2022-09-21 18.08.51.png" alt="截屏2022-09-21 18.08.51" style="zoom:40%;" />
    <img src="组成原理.assets/截屏2022-09-21 18.12.52.png" alt="截屏2022-09-21 18.12.52" style="zoom:45%;margin-left:100px" />
</center>
==将比自身优先级高的中断源对应的屏蔽位设为0，将自身或比自身优先级低的中断源对应的屏蔽位设为1==

（下图假设$D>A>C>B$）

<img src="组成原理.assets/截屏2022-09-22 15.24.42.png" alt="截屏2022-09-22 15.24.42" style="zoom:38%;" />

`DMA`

**流程**：CPU向DMA控制器指明要输入还是输出;要传送多少个数据；数据在主存、外设中的地址

​				1⃣️ 接受外设发出的DMA请求（外设传送一个字的请求），并向CPU发出总线请求

​				2⃣️ CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期

​				3⃣️ 确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数

​				4⃣️ 规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作

​				5⃣️ 向CPU报告DMA操作的结束

在DMA传送过程中，<u>DMA控制器将接管CPU的地址总线、数据总线和控制总线</u>，CPU的主存控制信号被禁止使用；而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作

<img src="组成原理.assets/截屏2022-09-22 15.43.11.png" alt="截屏2022-09-22 15.43.11" style="zoom:45%;" />

<img src="组成原理.assets/截屏2022-09-22 15.49.06.png" alt="截屏2022-09-22 15.49.06" style="zoom:40%;" />

**DMA传送方式**：

当I/O设备和CPU同时访问主存，I/O与主机并行工作（程序和传送并行工作），可能发生冲突

* **停止CPU访问主存**

	**优点**：控制简单						**缺点**：未充分发挥CPU对主存的利用率

<img src="组成原理.assets/截屏2022-09-22 16.12.17.png" alt="截屏2022-09-22 16.12.17" style="zoom:50%;" />

* **DMA与CPU交替访存**

	**优点**：不需要总线使用权的申请、建立和归还过程				**缺点**：硬件逻辑更为复杂

<img src="组成原理.assets/截屏2022-09-22 16.12.48.png" alt="截屏2022-09-22 16.12.48" style="zoom:40%;" />

* **周期挪用**（周期窃取）

	DMA访问主存有三种可能：

	1⃣️ CPU此时不访存（不冲突）2⃣️ CPU正访存（存取周期结束后CPU让出总线）3⃣️ CPU与DMA同时请求访存（I/O访存优先）

<img src="组成原理.assets/截屏2022-09-22 16.13.57.png" alt="截屏2022-09-22 16.13.57" style="zoom:45%;" />
