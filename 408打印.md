### 第2章 数据的表示和运算

`进制`

**进制的相互转换**

* **二进制 <—> 八进制、十六进制**

	$二进制\to 八进制：1111000010.01101\Rightarrow 001\ 111\ 000\ 010.011\ 010\Rightarrow 1702.32$（3位一组，每组转换成八进制符号）

	$二进制\to 十六进制：1111000010.01101\Rightarrow 0011\ 1100\ 0010.0110\ 1000\Rightarrow 3c2.68$（4位一组，每组转换成十六进制符号）

	$八进制\to 二进制：(251.5)_8\Rightarrow 010\ 101\ 001.101$（每位八进制对应成3位二进制）

	$十六进制\to 二进制：(AE86.1)_{16}\Rightarrow 1010\ 1110\ 0110.0001$（每位十六进制对应成4位二进制）

* **任意进制 —> 十进制**

	$二进制：10010010.110\Rightarrow 1\times 2^7+1\times 2^4+1\times 2^1+1\times 2^{-1}+1\times 2^{-2}=146.75$

	$八进制：251.5\Rightarrow 2\times 8^2+5\times 8^1+1\times 8^0+5\times 8^{-1}= 168.625$

	$十六进制：AE86.1\Rightarrow 10\times 16^3 + 14\times 16^2+8\times 16^1+6\times 16^0+1\times 16^{-1} = 44678.0625$

* **十进制 -> 任意进制**

	$十进制\to 二进制：75\Rightarrow 1001011；0.3\Rightarrow 0.01..B$

	<img src="408打印.assets/截屏2022-09-28 09.03.02.png" alt="截屏2022-09-28 09.03.02" style="zoom:40%;" />

	<img src="408打印.assets/截屏2022-09-28 09.10.09.png" alt="截屏2022-09-28 09.10.09" style="zoom:40%" />

**BCD码**

* **8421码**（8、4、2、1分别对应每一位的权值）

	$十进制\to 二进制：985\Rightarrow 1001\ 1000\ 0101$

	$加法：5+8=13\Rightarrow 0101+1000=1101+0110=1\ 0011=0001\ 0011$（若加法结果为10～15，则+6（0110）修正）

	<img src="408打印.assets/截屏2022-09-28 09.38.58-9218061.png" alt="截屏2022-09-28 09.38.58" style="zoom:33%;" />

* **余3码**（8421码 + 0011）

	<img src="408打印.assets/截屏2022-09-28 09.39.45-9218061.png" alt="截屏2022-09-28 09.39.45" style="zoom:33%;" />

* **2421码**（改变权值定义；2、4、2、1分别对应每一位的权值）

	<img src="408打印.assets/截屏2022-09-28 09.43.33-9218061.png" alt="截屏2022-09-28 09.43.33" style="zoom:33%;" />

	==表示0～4时，最高位为0；表示5～9时，最高位为1==

`定点数的表示与运算`

**无符号整数**

（全部二进制位均为数值位）

==$n\ bit无符号整数表示范围0～2^n-1，超出则溢出$==；==通常只有无符号整数，没有无符号小数==

**加法**：从最低位开始，按位相加，并往更高位进位

**减法**： 1⃣️ ==被减数”不变，“减数” 全部位按位取反、末位+1，减法变加法==

​				2⃣️ <u>从最低位开始，按位相加，并往更高位进位</u>

<img src="408打印.assets/截屏2022-09-28 09.57.06-9218061.png" alt="截屏2022-09-28 09.57.06" style="zoom:28%;" />

**有符号整数**（定点小数的各种操作均与定点整数一致）

**定点整数的编码表示**：<u>原码、反码、补码、移码</u>               **定点小数的编码表示**：<u>原码、反码、补码</u>

* **原码**                    **缺点**：符号位不能参与运算

* **补码**

	（符号位可以参与运算）

	**补码的加法**：==从最低位开始，按位相加（符号位参与运算）, 并往更高位进位==

	**补码的减法**：$[A]_补-[B]_补=[A]_补+[-B]_补$

	​                         1⃣️ ==被减数”不变，“减数” 全部位按位取反、末位+1，减法变加法==

	​				            2⃣️ <u>从最低位开始，按位相加，并往更高位进位</u>

	**补码加减运算器**：

	==适用于补码加减运算以及无符号整数的加减法==；==补码加减是否溢出根据OF判断，无符号数加减是否溢出根据CF判断==

	<img src="408打印.assets/截屏2022-10-27 11.05.40-9218061.png" alt="截屏2022-10-27 11.05.40" style="zoom:33%;" />

	<img src="408打印.assets/截屏2022-10-27 11.03.28-9218061.png" alt="截屏2022-10-27 11.03.28" style="zoom: 33%;" />

	==$$[x]_补 \to [-x]_补$$：符号位、数值位全部取反，末位加1==

	**定点整数**：==$$[x]_补 = 1,00..00\Rightarrow x=-2^n$$==

	**定点小数**：==$$[x]_补 = 1.00..00 \Rightarrow x=-1$$==

* **移码**

	（将补码的符号位取反即移码）

	常用于表示浮点数的阶码； ==只能用于表示整数==

**原码、反码、补码的相互转换**：

* **正数**               ==全部相同==

* **负数**

	$原码\Leftrightarrow 反码$：==符号位不变，数值位取反==				$反码\Rightarrow 补码$：==末位 + 1==

	$原码\Leftrightarrow 补码（机算）$：==符号位不变，数值位取反，末位 + 1== 	

	$原码\Leftrightarrow 补码（手算）$​：==从右往左找到第一个1, 这个1左边的所有“数值位”按位取反==

（字长为n+1，定点小数真值0的表示均与定点整数一致）

|      |           整数范围            |               小数范围                |                      真值0                      |
| :--: | :---------------------------: | :-----------------------------------: | :---------------------------------------------: |
| 原码 | ==$$-(2^n-1)\le x\le2^n-1$$== | ==$$-(1-2^{-n})\le x \le 1-2^{-n}$$== | ==不唯一，$$[+0]_原 = 00000,[-0]_原 = 10000$$== |
| 反码 |            同原码             |                同原码                 |  ==不唯一$$[+0]_反 = 00000,[-0]_反 = 11111$$==  |
| 补码 |  ==$$-2^n\le x \le 2^n-1$$==  |     ==$$-1\le x \le 1-2^{-n}$$==      |      ==唯一，$$[+0]_补 =[-0]_补 00000$$==       |
| 移码 |            同补码             |                  无                   |     ==唯一，$$[+0]_移 = [-0]_移 = 10000$$==     |

**定点小数扩展位数时与定点整数不一样**：

<img src="408打印.assets/截屏2022-09-28 18.34.30-9218061.png" alt="截屏2022-09-28 18.34.30" style="zoom:33%;" />

`溢出判断`

（只有“正数+正数”才会上溢；只有“负数+负数”才会下溢；双符号位补码又称模4补码，单符号位补码又称模2补码）

* **一位符号位**

	1⃣️ $设A的符号为A_s，B的符号为B_s， 运算结果的符号为S_s，则溢出逻辑表达式为V=A_sB_s\bar{S_s}+\bar{A_s}\bar{B_s}S_s$
			若V = 0，表示无溢出；若V = 1，表示有溢出

	2⃣️ $设符号位的进位为C_s，最高数值位的进位C_1，则V=C_s\oplus C_1;若V = 0，表示无溢出；若V = 1，表示有溢出$

	​		==$C_SC_1=01时，正溢出；C_sC_1=10时，负溢出$==

* **双符号位**

	$设两个符号位为S_1、S_2，则V=S_1\oplus S_2，若V = 0，表示无溢出；若V = 1，表示有溢出$

	<img src="408打印.assets/截屏2022-10-29 16.00.11-9218061.png" alt="截屏2022-10-29 16.00.11" style="zoom:33%;" />

==模4补码比模2补码更易检查加减运算中的溢出问题==

==存储模4补码仅需一个符号位==（两个符号位总是相同的）；只在把符号位送往ALU加减运算时，才把值同时送到ALU的双符号位）



`移位运算`

* **算数移位**

	（==符号位保持不变，仅对数值位进行移位==）

	* **原码**

		**右移**：高位补0，低位舍弃；若舍弃的位=0，则相当于除2；若舍弃的位≠0，则会丢失精度

		**左移**：低位补0，高位舍弃；若舍弃的位=0，则相当于乘2；若舍弃的位≠0，则会出现严重误差

		<img src="408打印.assets/截屏2022-10-25 09.11.13-9218061.png" alt="截屏2022-10-25 09.11.13" style="zoom:28%;" />

	* **反码**

		

		* **正数**               正数的反码算数移位与原码相同
		* **负数**              **右移**：高位补1， 低位舍弃                **左移**：低位补1，高位舍弃（由于负数的反码数值位与原码相反）

	* **补码**

		* **正数**               正数的补码算数移位与原码相同

		* **负数**              **右移**：高位补1， 低位舍弃                **左移**：低位补0，高位舍弃

			（由于负数补码中，最右边的1及其右边同原码，最右边的1的左边同反码）

			<img src="408打印.assets/截屏2022-10-25 09.26.01-9218061.png" alt="截屏2022-10-25 09.26.01" style="zoom:25%;" />

* **逻辑移位**

	（不区分符号位与数值位，所有位都移动）

	**右移**：高位补0，低位舍弃           **左移**：低位补0，高位舍弃

	<img src="408打印.assets/截屏2022-10-25 09.34.46-9218061.png" alt="截屏2022-10-25 09.34.46" style="zoom:25%;" />

* **循环移位**

	**不带进位位**：用移出的位补上空缺                **带进位位**：移出的位放到进位位，原进位位补上

	<img src="408打印.assets/截屏2022-10-25 09.39.43-9218061.png" alt="截屏2022-10-25 09.39.43" style="zoom:33%;" />

	（注意：不管带不带进位位，不管左移还是右移，进位位都会被更新）

`乘法`

* **原码一位乘法**

	（设机器字长位n+1位，包含1位符号位，$[x]_原=1.1101，[y]_原=0.1011$）

	<img src="408打印.assets/截屏2022-10-25 09.59.07.png" alt="截屏2022-10-25 09.59.07" style="zoom:25%;" />

	​    <img src="408打印.assets/截屏2022-10-25 10.02.51.png" alt="截屏2022-10-25 10.02.51" style="zoom:28%"/>

	1⃣️ 开始前，先将ACC置0              2⃣️ 将<u>被乘数、乘数取绝对值</u>分别存入X、MQ中

	3⃣️ 若当前位（即MQ的最低位）=1，则ACC加上被乘数；若当前位=0，则ACC加上0

	4⃣️ ACC与MQ联合起来一起逻辑右移一位，高位补0           5⃣️ 重复n次         

	6⃣️ 将被乘数、乘数的符号位异或替换掉ACC左边第一位，图中红色部分即乘法结果

* **补码一位乘法**

	<img src="408打印.assets/截屏2022-10-25 10.24.42-9218061.png" alt="截屏2022-10-25 10.24.42" style="zoom:33%;" />

	$设机器字长为5位（含1位符号位，n=4），x=-0.1101, y=+0.1011，[x]_补=11.0011，[-x]_补=00.1101， [y]_补=0.1011$

	$辅助位-MQ中最低位=1时，(ACC)+[x]_补、辅助位-MQ中最低位=0时，(ACC)+0、辅助位-MQ中最低位=-1时，(ACC)+[-x]_补$

	符号位、数值位都是由<u>被乘数和乘数进行n轮加法、移位</u>，==最后再多来一次加法==

	每次移位是补码的算数右移；乘数的符号位参与运算

`除法`

* **原码（恢复余数法）**

	$设机器字长为5位（含1位符号位，n=4），x=0.1011, y=0.1101，|x|=0.1011, |y|=0.1101, [|y|]_补=0.1101, [-|y|]_补=1.0011$

	<img src="408打印.assets/截屏2022-10-29 14.39.51.png" alt="截屏2022-10-29 14.39.51" style="zoom:28%;padding-left:0px" />

	​    <img src="408打印.assets/截屏2022-10-29 14.50.47.png" alt="截屏2022-10-29 14.50.47" style="zoom:30%" />

	1⃣️ 开始前，先将MQ置0              2⃣️ 将被除数、除数取绝对值分别存入ACC、X中


	3⃣️ $ACC+[-|y|]_补送至ACC$，同时MQ最低位置1，若ACC中为负数，则$ACC+[|y|]_补$，MQ最低位置0

	4⃣️ 将ACC、MQ联合起来逻辑左移一位，低位补0           5⃣️重复n次

	6⃣️ 将被除数、除数的符号位异或替换掉MQ左边第一位，MQ即商；余数需要乘以$2^{-n}$

	==左移n次，上商n+1次，最后一次上商余数不左移==（若最后一步，余数为负，也需要恢复余数并商0）

	<img src="408打印.assets/截屏2022-10-29 14.57.52-9218061.png" alt="截屏2022-10-29 14.57.52" style="zoom:30%;" />

* 原码（不恢复余数法、加减交替法）

	<img src="408打印.assets/截屏2022-10-29 15.12.11-9218061.png" alt="截屏2022-10-29 15.12.11" style="zoom:30%;" />

	**加减次数**：==n+1 或 n+2==          **移位次数**：==n==

	==只在最终余数为负时，才需要恢复余数==

`算术逻辑单元（ALU）`

由<u>组合逻辑电路</u>构成的，==最基本的部件是并行加法器==

<img src="408打印.assets/截屏2022-10-26 11.40.13-9218061.png" alt="截屏2022-10-26 11.40.13" style="zoom:30%;" />

`电路的基本原理、加法器设计`

**一位全加器**

<img src="408打印.assets/截屏2022-10-27 09.34.39.png" alt="截屏2022-10-27 09.34.39" style="zoom:30%;" />

​    <img src="408打印.assets/截屏2022-10-27 09.35.09.png" alt="截屏2022-10-27 09.35.09" style="zoom:33%" />


**进位产生的原因**：==1⃣️ A和B都为1   2⃣️ AB其中一个为1且进位为1==（其中1⃣️为进位生成信号，2⃣️为进位传递信号）

**串行加法器**

只有一个全加器，数据逐位串行送入加法器中进行运算；进位触发器用来寄存进位信号，以便参与下一次运算

如果操作数长n位，加法就要分n次进行，每次产生一位和，并且串行逐位地送回寄存器

<img src="408打印.assets/截屏2022-10-27 09.40.36-9218061.png" alt="截屏2022-10-27 09.40.36" style="zoom:33%;" />

**串行进位的并行加法器**

<img src="408打印.assets/截屏2022-10-27 09.42.31-9218061.png" alt="截屏2022-10-27 09.42.31" style="zoom:33%;" />

串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的

<u>在串行进位的并行加法器中，影响加法器运算速度的关键因素是进位传递延迟</u>

**采用并行进位的目的**：<u>提高加法器运算速度</u>

`C语言类型转换`

==C语言中定点整数是用“补码”存储的==

$无符号\Leftrightarrow 有符号$：==不改变数据内容，只改变解释方式==

$长整数\Rightarrow 短整数$：==高位截断，保留低位==（$0\times 000286a1\Rightarrow 0\times 86a1$）

$短整数\Rightarrow 长整数$：==符号扩展（符号位补1）==（$1110\ 1111\ 0001\ 1111\Rightarrow 1111\ 1111\ 1111\ 1111\ 1110\ 1111\ 0001\ 1111$）

`浮点数`

<img src="408打印.assets/截屏2022-11-21 16.49.52-9218061.png" alt="截屏2022-11-21 16.49.52" style="zoom:25%;" />

**阶码**：常用<u>补码或移码</u>表示的定点整数；阶码E反映浮点数的表示范围及小数点的实际位置

​			（阶码为正，相当于算术左移一位；阶码为负，相当于算术右移一位）

**尾数**：常用<u>原码或补码</u>表示的定点小数；尾数M的数值部分的位数n反映浮点数的精度

**浮点数的真值**：$N=r^E\times M（r为阶码的底，通常取2）$

<img src="408打印.assets/截屏2022-11-21 17.03.14-9218061.png" alt="截屏2022-11-21 17.03.14" style="zoom:30%;" />

### 第4章 指令系统

`指令分类`

* **零地址指令**

	1⃣️ 不需要操作数，如空操作、停机、关中断等指令

	2⃣️ 堆栈计算机，==两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶==

* **一地址指令**

	<img src="408打印.assets/截屏2022-10-16 09.56.12.png" alt="截屏2022-10-16 09.56.12" style="zoom:33%;" />

	1⃣️ 只需要单操作数，如加1、减1、取反、求补等（完成一条指令需要3次访存：取指→读A1→写A1）

	2⃣️ 需要两个操作数，但其中一个操作数隐含在某个寄存器（完成一条指令需要2次访存：取指→读A1）

	（即<u>单地址指令可能有一个操作数，也可能有两个操作数</u>）

* **二地址指令**

	<img src="408打印.assets/截屏2022-10-16 10.00.02.png" alt="截屏2022-10-16 10.00.02" style="zoom:33%;" />

	常用于需要两个操作数的算术运算、逻辑运算相关指令（完成一条指令需要访存4次：取指→读A1→读A2 >写A1）

* **三地址指令**

	<img src="408打印.assets/截屏2022-10-16 10.00.27.png" alt="截屏2022-10-16 10.00.27" style="zoom:33%;" />

	常用于需要三个操作数的算术运算、逻辑运算相关指令（完成一条指令需要访存4次：取指→读A1→读A2→写A3）

* **四地址指令**

	<img src="408打印.assets/截屏2022-10-16 10.03.11.png" alt="截屏2022-10-16 10.03.11" style="zoom:33%;" />

	正常情况下：取指令之后PC+1，指向下一条指令；而四地址指令：==执行指令后，将PC的值修改为A4所指地址==

	完成一条指令需要访存4次：取指→读A1→读A2→写A3

`扩展操作码`

**定长操作码**

（在指令字的最高位部分分配固定的若干位表示操作码）

**优点**：定长操作码对于简化计算机硬件设计，<u>提高指令译码和识别速度很有利</u>

**缺点**：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限

**不定长操作码**

（全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置上）
**优点**：在指令字长有限的前提下仍保持比较丰富的指令种类          **缺点**：<u>增加了指令译码和分析的难度，使控制器的设计复杂化</u>

<img src="408打印.assets/截屏2022-10-16 10.12.06.png" alt="截屏2022-10-16 10.12.06" style="zoom:33%;" />

**采用扩展操作码的目的**：==保持指令字长度不变而增加指令的数量==

**设计扩展操作码原则**

1⃣️ 不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同    2⃣️ 各指令的操作码一定不能重复

==$设地址长度为n，上一层留出m种状态，下一层可扩展出m\times 2^n种状态$==

`指令寻址`

（确定下一条欲执行指令的指令地址）

* **顺序寻址**

	对于定长指令字结构且主存按字编址：每次取指令结束后，$(PC)+1\to PC$

	对于变长指令字结构且主存按字编址：每次取指令结束后，根据操作码判断这条指令的总字节数n，$(PC)+n\to PC$

* **跳跃寻址**

	每次取指令结束后，$(PC)+1\to PC$，读指令发现是转移指令（JMP、CALL），将PC中的值修改为指令中的地址码

`数据寻址`

（确定本条指令的地址码指明的真实地址）

**采用不同寻址方式的目的**：==为了缩短指令字长，扩大寻址空间，提高编程的灵活性==；但这也==提高了指令译码的复杂度==

<u>程序控制是靠转移指令而非寻址方式实现的</u>

* **立即寻址**

	（形式地址A就是操作数本身，又称为立即数，一般采用补码形式）

	==一次访存==（仅当取指令时；执行指令不需要访存）

	**优点**：指令执行阶段不访问主存，指令执行时间最短     **缺点**：A的位数限制了立即数的范围

* **直接寻址**

	（指令字中的形式地址A就是操作数的真实地址）

	==两次访存==（取指令、执行指令各一次）

	**优点**：简单，指令执行阶段仅访问一次主存，不需专门计算操作数的地址

	**缺点**：A的位数决定了该指令操作数的寻址范围（寻址范围小）；==操作数的地址不易修改==

	<img src="408打印.assets/截屏2022-10-16 11.44.43.png" alt="截屏2022-10-16 11.44.43" style="zoom:25%;" />

* **间接寻址**

	（指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址）

	**优点**：==可扩大寻址范围==；便于编制程序（用间接寻址可以方便地完成子程序返回）

	**缺点**：指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）

	<img src="408打印.assets/截屏2022-10-16 11.47.27.png" alt="截屏2022-10-16 11.47.27" style="zoom:25%;" />

* **寄存器寻址**

	（在指令字中直接给出操作数所在的寄存器编号，其操作数在所指的寄存器内）

	==一次访存==（仅当取指令时；执行指令不需要访存）

	**优点**：指令在执行阶段不访问主存，只访问寄存器；指令字短且执行速度快；支持向量/矩阵运算

	**缺点**：寄存器价格昂贵

	<img src="408打印.assets/截屏2022-10-16 11.53.19.png" alt="截屏2022-10-16 11.53.19" style="zoom:28%;" />

* **寄存器间接寻址**

	（寄存器中给出的不是一个操作数，而是操作数所在主存单元的地址）

	==两次访存==（取指令、执行指令各一次）；比一般间接寻址相比速度更快

	<img src="408打印.assets/截屏2022-10-16 11.57.50.png" alt="截屏2022-10-16 11.57.50" style="zoom:30%;" />

* **隐含寻址**

	（不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址）

	**优点**：有利于缩短指令字长       **缺点**：需增加存储操作数或隐含地址的硬件

	<img src="408打印.assets/截屏2022-10-16 12.00.02.png" alt="截屏2022-10-16 12.00.02" style="zoom:28%;" />

* **偏移寻址**

	* **基址寻址**

		（将CPU中基址<u>寄存器BR的内容（不可变）</u>加上指令格式中的<u>形式地址A（可变）</u>，而形成操作数的有效地址）

		<u>基址寄存器</u>是面向操作系统的，其==内容由操作系统或管理程序确定==

		当<u>采用通用寄存器作为基址寄存器</u>时，可由用户决定哪个寄存器作为基址寄存器，但其==内容仍由操作系统确定==

		**优点**：可扩大寻址范围；==便于程序“浮动”==（整段程序在内存里的浮动）；==方便实现多道程序并发运行==

		<img src="408打印.assets/截屏2022-10-16 12.08.14.png" alt="截屏2022-10-16 12.08.14" style="zoom:33%;" />

	* **变址寻址**

		（有效地址EA等于<u>变址寄存器IX的内容（可变）</u>与指令字中的<u>形式地址A（不可变）</u>相加之和）

		==IX可为变址寄存器，也可用通用寄存器作为变址寄存器==；==适合编制循环程序==（结合数组）

		变址寄存器是面向用户的，在程序执行过程中，==变址寄存器的内容可由用户改变==

		<img src="408打印.assets/截屏2022-10-16 12.16.43.png" alt="截屏2022-10-16 12.16.43" style="zoom:28%;" />

	* **相对寻址**

		把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，A是相对于PC所指地址（下一条指令地址）的位移量，可正可负，补码表示

		==便于程序浮动==（一段代码在程序内部的浮动）；==广泛应用于转移指令==

		<img src="408打印.assets/截屏2022-10-16 16.54.51.png" alt="截屏2022-10-16 16.54.51" style="zoom: 30%;" />

* **堆栈寻址**

	（操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址）

	**硬堆栈**：由寄存器组成的堆栈          **软堆栈**：在内存中划分出来的堆栈

	**入栈**：$有效地址 = (SP)$          **出栈**：$有效地址 = (SP) \pm 1$

	**访存次数**：==硬堆栈，指令执行时不访存；软堆栈，指令执行时访存一次==

	<img src="408打印.assets/截屏2022-10-16 17.11.49.png" alt="截屏2022-10-16 17.11.49" style="zoom:28%;" />

	​    <img src="408打印.assets/截屏2022-10-16 17.10.44.png" alt="截屏2022-10-16 17.10.44" style="zoom:28%"/>

`CISC和RISC`

**CISC**：一条指令完成一个复杂的基本功能；代表：x86架构，主要用于笔记本、台式机

**RISC**：一条指令完成一个基本动作，多条指令组合完一个复杂的基本功能；代表：ARM架构，主要用于手机、平板

<img src="408打印.assets/截屏2022-10-14 10.02.09.png" alt="截屏2022-10-14 10.02.09" style="zoom:33%;" />

==相比CISC，RISC的指令格式和寻址种类较少==

### 第6章 总线

`概述`

<img src="../../../组成原理.assets/截屏2022-11-04 14.37.14.png" alt="截屏2022-11-04 14.37.14" style="zoom:15%;" />

==同一时刻只能有一个部件发送数据，但是可有多个部件接受数据==；==使用总线结构便于增减外设，同时减少信息传输线的条数==

<u>主存通过总线的类型来识别信息是地址还是数据，CPU通过控制单元（CU）来识别信息是地址还是数据</u>

在现代微机主板上，采用局部总线技术的作用是<u>节省系统的总带宽</u>

只有主设备才能获得总线控制权，总线上的信息传输由主设备启动，一条总线上可以有多个设备作为主设备，但在同一时刻只能有一个主设备控制总线的传输操作

**总线的分类**

* **按数据传输格式**                 1⃣️ 串行总线<u>（USB）</u>  2⃣️ 并行总线<u>（PCI、EISA、ISA）</u>

* **按总线功能**

	* **片内总线**

		片内总线是芯片内部的总线，它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线

	* **系统总线**

		系统总线是计算机系统内各功能部件（CPU、 主存、I/O接口）之间相互连接的总线

		数据总线：传输各功能部件之间的数据信息，包括指令和操作数；根数与机器字长、存储字长有关；==双向传输==

		地址总线：传输地址信息，包括==主存单元或I/O端口的地址==；根数与主存地址空间大小及设备数量有关；==单向传输==

		控制总线：传输控制信息，一根控制线传输一个信号；<u>有出（CPU送出的控制命令），有入（主存或外设返回CPU的反馈信号）</u>，即==双向传输==

	* **通信总线**（外部总线）

		用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线

**系统总线的结构**

* **单总线结构**

	CPU、主存、I/O设备（通过I/O接口）都连接在<u>一组</u>总线上，允许I/O设备之间、I/O设备和CPU之间或I/O设备与主存之间直接交换信息

	**优点**：结构简单，成本低，易于接入新的设备

	**缺点**：带宽低、负载重，多个部件只能争用唯一的总线，且==不支持并行传送操作==

	<img src="408打印.assets/截屏2022-11-04 14.57.35.png" alt="截屏2022-11-04 14.57.35" style="zoom:28%;" />

	（单总线并不是指只有一根信号线，系统总线按传送信息的不同可以细分为地址总线、数据总线和控制总线）

* **双总线结构**

	双总线结构有两条总线，一条是<u>主存总线</u>，用于CPU、主存和通道之间进行数据传送；另一条是<u>I/O总线</u>，用于多个外部设备与通道之间进行数据传送

	**优点**：将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线分离       **缺点**：需要增加通道等硬件设备

	<img src="408打印.assets/截屏2022-11-04 15.05.10.png" alt="截屏2022-11-04 15.05.10" style="zoom:25%;" />

* **三总线结构**

	三总线结构是在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为==主存总线、I/O总线和DMA总线==

	**优点**：提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量               **缺点**：系统工作效率较低

	支持突发传输方式（一次总线事务中，主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据）

	<img src="408打印.assets/截屏2022-11-04 15.09.16.png" alt="截屏2022-11-04 15.09.16" style="zoom:25%;" />

`总线的性能指标`

* **传输周期**（总线周期）

	一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段），通常<u>由若干个总线时钟周期构成</u>

* **工作频率**

	总线上各种操作的频率，为总线周期的倒数；实际上指一秒内传送几次数据

	==$若总线周期 = N个时钟周期（传送一个字需要N个时钟周期），则总线的工作频率 = \frac{时钟频率}{N}$==

* **时钟周期**

	即机器的时钟周期；计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制

* **时钟频率**

	即机器的时钟频率，为时钟周期的倒数；若时钟周期为T，则时钟频率为1/T；实际上指一秒内有多少个时钟周期

* **总线宽度**（总线位宽）

	总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位总线

* **总线带宽**

	可理解为<u>总线的数据传输率</u>，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单
	位可用字节/秒(B/s)表示

	==$总线带宽=总线工作频率\times 总线宽度（bit/s）=\frac{总线宽度}{总线周期}（bit/s）$==

	==$总线带宽=总线工作频率\times （总线宽度/8）（B/s）=\frac{总线宽度/8}{总线周期}（B/s）$==

* **总线复用**

	指<u>一种信号线在不同的时间传输不同的信息</u>；可以使用较少的线传输更多的信息，从而节省了空间和成本

* **信号线数**

	地址总线、数据总线和控制总线3种总线数的总和称为信号线数

`总线操纵和定时`

**总线周期的四个阶段**

1⃣️ 申请分配阶段：由需要使用总线的主模块(或主设备)提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者，也可将此阶段细分为传输请求和总线仲裁两个阶段

2⃣️ 寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块

3⃣️ 传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送

4⃣️ 结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权

**总线定时**

（指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议或规则）

* **同步通信**（同步定时方式）

	（由==统一时钟控制数据传送==；若干个时钟产生<u>相等的时间间隔</u>，每个间隔构成一个总线周期；在一个总线周期中，发送方和接收方可进行一次数据传送；==总线周期长度固定==）

	1⃣️ CPU在T1时刻的上升沿给出地址信息

	2⃣️ 在T2的上升沿给出读命令(低电平有效)，与地址信息相符合的输入设备按命令进行-系列的内部操作，且必须在T3的上升沿来之前将CPU所需的数据送到数据总线上

	3⃣️ CPU在T3时钟周期内，将数据线上的信息传送到其内部寄存器中

	4⃣️ CPU在T4的上升沿撤销读命令，输入设备不再向数据总线上传送数据，撤销它对数据总线的驱动

	<img src="408打印.assets/截屏2022-11-05 15.01.55.png" alt="截屏2022-11-05 15.01.55" style="zoom:30%;" />

	**优点**：传送速度快，具有较高的传输速率；总线控制逻辑简单

	**缺点**：主从设备属于强制性同步，不能及时进行数据通信的有效性检验，==可靠性较差==

	同步通信适用于==总线长度较短及总线所接部件的存取时间比较接近（即速度相近）==的系统

* **异步通信**（异步定时方式）

	（采用应答方式，没有公共时钟标准，即==不采用时钟信号，只采用握手信号，每次握手的过程完成一次通信==；主设备提出交换信息的请求信号，经接口传送到从设备，从设备接到主设备的请求后，通过接口向主设备发出回答信号）

	**根据 “请求”和“回答” 信号的撤销是否互锁，分为以下3种类型：**

	* **不互锁方式**

		主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号

		从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号；双方不存在互锁关系

		==速度最快，可靠性最差==

	* **半互锁方式**

		主设备发出“请求”信号后，必须等待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系

		从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动
		撤销“回答”信号，不存在互锁关系

	* **全互锁方式**

		主设备发出“请求”信号后，必须等待从设备“回答”后，才撤销“请求”信号

		从设备发出“回答”信号，必须等待获知主设备“请求”信号已撤销后，再撤销其“回答”信号；双方存在互锁关系

		==速度最慢，可靠性最好==

	**优点**：==总线周期长度可变==，<u>能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换</u>，自动适应时间的配合

	**缺点**：比同步控制方式稍复杂一些，==速度比同步定时方式慢==

	适用于==速度相差很大==的两个设备

	<img src="408打印.assets/截屏2022-11-07 14.52.56.png" alt="截屏2022-11-07 14.52.56" style="zoom:33%;" />

* **半同步通信**：同步、异步结合

* **分离式通信**：充分挖掘系统总线每瞬间的潜力

<u>在不同速度的设备之间传送数据，可以选用同步控制方式，也可选用异步控制方式</u>